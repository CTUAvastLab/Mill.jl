var documenterSearchIndex = {"docs":
[{"location":"missing/#Missing-values","page":"Missing values","title":"Missing values","text":"","category":"section"},{"location":"missing/","page":"Missing values","title":"Missing values","text":"At the moment, Mill.jl features an initial and naive approach to missing values. We assume that ArrayNode have missing values replaced by zeros, which is not optimal but in many situations it works reasonably well.","category":"page"},{"location":"missing/","page":"Missing values","title":"Missing values","text":"BagNodes with missing features are indicated by Bags being set to [0:-1] with missing as a data and metadata. This can be seamlessly concatenated or sub-set, if the operation makes sense.","category":"page"},{"location":"missing/","page":"Missing values","title":"Missing values","text":"Couple examples from unit tests. Let's define full and empty BagNode","category":"page"},{"location":"missing/","page":"Missing values","title":"Missing values","text":"julia> a = BagNode(ArrayNode(rand(3,4)),[1:4], nothing)\nBagNode with 1 bag(s)\n  └── ArrayNode(3, 4)\n\njulia> e = BagNode(missing, AlignedBags([0:-1]), nothing)\nBagNode with 1 empty bag(s)","category":"page"},{"location":"missing/","page":"Missing values","title":"Missing values","text":"We can concatenate them as follows.","category":"page"},{"location":"missing/","page":"Missing values","title":"Missing values","text":"julia> x = reduce(catobs,[a, e])\nBagNode with 2 bag(s)\n  └── ArrayNode(3, 4)","category":"page"},{"location":"missing/","page":"Missing values","title":"Missing values","text":"Notice, that the ArrayNode has still the same dimension as ArrayNode of just a. The missing second element, corresponding to e is indicated by the second bags being 0:-1 as follows:","category":"page"},{"location":"missing/","page":"Missing values","title":"Missing values","text":"julia> x.bags\nAlignedBags(UnitRange{Int64}[1:4, 0:-1])","category":"page"},{"location":"missing/","page":"Missing values","title":"Missing values","text":"We can get back the missing second element as","category":"page"},{"location":"missing/","page":"Missing values","title":"Missing values","text":"julia> x[2]\nBagNode with 1 empty bag(s)","category":"page"},{"location":"missing/","page":"Missing values","title":"Missing values","text":"During forward (and backward) pass, the missing values in BagNodes are filled in aggregation by zeros. ** In order this feature to work, the Aggregation needs to know dimension, therefore use MissingAggregation, which can handle this.** In the future, MissingAggregation will be made default.","category":"page"},{"location":"missing/","page":"Missing values","title":"Missing values","text":"Last but not least, ProductNodes cannot handle missing values, as the missingness is propagated to its leaves, i.e.","category":"page"},{"location":"missing/","page":"Missing values","title":"Missing values","text":"julia> ProductNode((a,e))\nProductNode{2}\n  ├── BagNode with 1 bag(s)\n  │     └── ArrayNode(3, 4)\n  └── BagNode with 1 empty bag(s)","category":"page"},{"location":"#Mill.jl","page":"Mill.jl","title":"Mill.jl","text":"","category":"section"},{"location":"","page":"Mill.jl","title":"Mill.jl","text":"Documentation for Mill.jl","category":"page"},{"location":"datanodes/#Architecture-of-Data-nodes","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"","category":"section"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"DataNodes are lightweight wrappers around data, such as Array, DataFrames, etc. Their primary purpose is to allow their nesting. It is possible to create subsets using getindex and concatenate them using cat. Note that internally, nodes are concatenated using reduce(catobs, ...). Similarly getindex is redirected to subset. This is needed such that operations over Matrices, Vectors, and DataFrames are consistent with the library.","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"Let's take a look on an example on a simple ArrayNode holding a matrix or a vectors.","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"ArrayNode has a simple structure holding only Array, which is considered the data and optionally some metadata, which can be literally anything.","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"struct ArrayNode{A,C} <: AbstractNode\n    data::A\n    metadata::C\nend","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"ArrayNode had overloaded a getindex to support indexing. But the getindex just calls subset(x::ArrayNode, idxs), which is used to correctly slice arrays according to the last dimension.","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"This mean that if you want to define your own DataNode, in order to be compatible with the rest of the library it has to implement subset and reduce(::typeof{catobs}, Vector{T}) where {T<:YourType}","category":"page"},{"location":"datanodes/#An-Example-of-how-to-add-a-custom-datatype-–-a-container-for-unix-pathnames-struct","page":"Architecture of Data nodes","title":"An Example of how to add a custom datatype –- a container for unix pathnames struct","text":"","category":"section"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"We give it a twist, such that the extractor will be part of the model definition, which is going to be cute.","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"Let's start by defining the structure holding pathnames, supporting nobs joining of two structures and indexing into the structure. A last touch is to extend the pretty printing.","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"struct PathNode{S<:AbstractString,C} <: AbstractNode\n    data::Vector{S}\n    metadata::C\nend\n\nPathNode(data::Vector{S}) where {S<:AbstractString} = PathNode(data, nothing)\n\nBase.ndims(x::PathNode) = Colon()\nStatsBase.nobs(a::PathNode) = length(a.data)\nStatsBase.nobs(a::PathNode, ::Type{ObsDim.Last}) = nobs(a)\n\nfunction Base.reduce(::typeof(Mill.catobs), as::Vector{T}) where {T<:PathNode}\n    data = reduce(vcat, [x.data for x in as])\n    metadata = reduce(catobs, [a.metadata for a in as])\n    PathNode(data, metadata)\nend\n\nBase.getindex(x::PathNode, i::VecOrRange) = PathNode(subset(x.data, i), subset(x.metadata, i))\n\nMill.dsprint(io::IO, n::PathNode; pad=[], s=\"\", tr=false) = paddedprint(io, \"PathNode$(size(n.data))$(tr_repr(s, tr))\")","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"Similarly, we define a ModelNode which will be a counterpart processing the data. Note that the part of the ModelNode is a function which converts the pathanme string to Matrix (or other Mill structures). Again, we add a support for pretty printing.","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"struct PathModel{T,F} <: AbstractMillModel\n    m::T\n    path2mill::F\nend\n\nFlux.@functor PathModel\n\n(m::PathModel)(x::PathNode)  = m.m(m.path2mill(x))\n\nfunction Mill.modelprint(io::IO, m::PathModel; pad=[], s=\"\", tr=false)\n    c = COLORS[(length(pad)%length(COLORS))+1]\n    paddedprint(io, \"PathModel$(tr_repr(s, tr))\\n\", color=c)\n    paddedprint(io, \"  └── \", color=c, pad=pad)\n    modelprint(io, m.m, pad=[pad; (c, \"      \")])\nend","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"Finally, let's define function path2mill, which converts a list of strings to Mill internal structure.","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"function path2mill(s::String)\n\tss = String.(split(s, \"/\"))\n\tBagNode(ArrayNode(Mill.NGramMatrix(ss, 3, 256, 2053)), AlignedBags([1:length(ss)]))\nend\n\npath2mill(ss::Vector{S}) where {S<:AbstractString} = reduce(catobs, map(path2mill, ss))\npath2mill(ds::PathNode) = path2mill(ds.data)\n","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"And then, let's test the solution","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"ds = PathNode([\"/etc/passwd\", \"/home/tonda/.bashrc\"])\npm = PathModel(reflectinmodel(path2mill(ds), d -> Dense(d, 10, relu)), path2mill)\npm(ds).data","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"A final touch would be to overload the reflectinmodel as","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"\nfunction Mill.reflectinmodel(ds::PathNode, args...)\n\tpm = reflectinmodel(path2mill(ds), args...)\n\tPathModel(pm, path2mill)\nend\n","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"which can make it seamless","category":"page"},{"location":"datanodes/","page":"Architecture of Data nodes","title":"Architecture of Data nodes","text":"ds = PathNode([\"/etc/passwd\", \"/home/tonda/.bashrc\"])\npm = reflectinmodel(ds, d -> Dense(d, 10, relu))\npm(ds).data","category":"page"}]
}
