<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bag aggregation · Mill.jl</title><meta name="title" content="Bag aggregation · Mill.jl"/><meta property="og:title" content="Bag aggregation · Mill.jl"/><meta property="twitter:title" content="Bag aggregation · Mill.jl"/><meta name="description" content="Documentation for Mill.jl."/><meta property="og:description" content="Documentation for Mill.jl."/><meta property="twitter:description" content="Documentation for Mill.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Mill.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Mill.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../motivation/">Motivation</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../nodes/">Nodes</a></li><li><a class="tocitem" href="../more_on_nodes/">More on nodes</a></li><li><a class="tocitem" href="../reflectin/">Model reflection</a></li><li class="is-active"><a class="tocitem" href>Bag aggregation</a><ul class="internal"><li><a class="tocitem" href="#Non-parametric-aggregation"><span>Non-parametric aggregation</span></a></li><li><a class="tocitem" href="#Parametric-aggregation"><span>Parametric aggregation</span></a></li><li><a class="tocitem" href="#Weighted-aggregation"><span>Weighted aggregation</span></a></li><li><a class="tocitem" href="#Default-aggregation-values"><span>Default aggregation values</span></a></li></ul></li><li><a class="tocitem" href="../leaf_data/">Data in leaves</a></li><li><a class="tocitem" href="../missing/">Missing data</a></li><li><a class="tocitem" href="../custom/">Custom nodes</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/musk/musk/">Musk</a></li><li><a class="tocitem" href="../../examples/gnn/">GNNs in 16 lines</a></li><li><a class="tocitem" href="../../examples/dag/">DAGs</a></li><li><a class="tocitem" href="../../examples/jsons/">Processing JSONs</a></li></ul></li><li><span class="tocitem">External tools</span><ul><li><a class="tocitem" href="../../tools/hierarchical/">HierarchicalUtils.jl</a></li></ul></li><li><span class="tocitem">Public API</span><ul><li><a class="tocitem" href="../../api/aggregation/">Aggregation</a></li><li><a class="tocitem" href="../../api/bags/">Bags</a></li><li><a class="tocitem" href="../../api/data_nodes/">Data nodes</a></li><li><a class="tocitem" href="../../api/model_nodes/">Model nodes</a></li><li><a class="tocitem" href="../../api/special_arrays/">Special Arrays</a></li><li><a class="tocitem" href="../../api/switches/">Switches</a></li><li><a class="tocitem" href="../../api/utilities/">Utilities</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../citation/">Citation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Bag aggregation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bag aggregation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CTUAvastLab/Mill.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CTUAvastLab/Mill.jl/blob/master/docs/src/manual/aggregation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Bag-aggregation"><a class="docs-heading-anchor" href="#Bag-aggregation">Bag aggregation</a><a id="Bag-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Bag-aggregation" title="Permalink"></a></h1><p>Aggregation operators in <a href="https://github.com/CTUAvastLab/Mill.jl"><code>Mill.jl</code></a> are all subtypes of <a href="../../api/aggregation/#Mill.AbstractAggregation"><code>AbstractAggregation</code></a>. These structures are responsible for mapping of vector representations of multiple instances into a single vector. They all operate element-wise and independently of dimension and thus the output has the same size as representations on the input, unless the <a href="#Concatenation">Concatenation</a> of multiple operators is used.</p><p>Some setup:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = 2</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; X = Float32.([1 2 3 4; 8 7 6 5])</code><code class="nohighlight hljs ansi" style="display:block;">2×4 Matrix{Float32}:
 1.0  2.0  3.0  4.0
 8.0  7.0  6.0  5.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bags = AlignedBags([1:1, 2:3, 4:4])</code><code class="nohighlight hljs ansi" style="display:block;">AlignedBags{Int64}(UnitRange{Int64}[1:1, 2:3, 4:4])</code></pre><p>Different choice of operator, or their combinations, are suitable for different problems. Nevertheless, because the input is interpreted as an unordered bag of instances, every operator is invariant to permutation and also does not scale when increasing size of the bag.</p><h2 id="Non-parametric-aggregation"><a class="docs-heading-anchor" href="#Non-parametric-aggregation">Non-parametric aggregation</a><a id="Non-parametric-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Non-parametric-aggregation" title="Permalink"></a></h2><h3 id="Max-aggregation"><a class="docs-heading-anchor" href="#Max-aggregation">Max aggregation</a><a id="Max-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Max-aggregation" title="Permalink"></a></h3><p><a href="../../api/aggregation/#Mill.SegmentedMax"><code>SegmentedMax</code></a> implements a simple <code>max</code> and is the most straightforward operator defined in one dimension as follows:</p><p class="math-container">\[a_{\max}(\{x_1, \ldots, x_k\}) = \max_{i = 1, \ldots, k} x_i\]</p><p>where <span>$\{x_1, \ldots, x_k\}$</span> are all instances of the given bag. In <code>Mill</code>, the operator is constructed this way:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_max = SegmentedMax(d)</code><code class="nohighlight hljs ansi" style="display:block;">SegmentedMax(ψ = Float32[0.0, 0.0])</code></pre><p>The application is straightforward:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_max(X, bags)</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Float32}:
 1.0  3.0  4.0
 8.0  7.0  5.0</code></pre><p>Since we have three bags, we have three columns in the output, each storing the maximal element over all instances of the given bag.</p><h3 id="Mean-aggregation"><a class="docs-heading-anchor" href="#Mean-aggregation">Mean aggregation</a><a id="Mean-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Mean-aggregation" title="Permalink"></a></h3><p><a href="../../api/aggregation/#Mill.SegmentedMean"><code>SegmentedMean</code></a> implements <code>mean</code> function, defined as:</p><p class="math-container">\[a_{\operatorname{mean}}(\{x_1, \ldots, x_k\}) = \frac{1}{k} \sum_{i = 1}^{k} x_i\]</p><p>and used the same way:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_mean = SegmentedMean(d)</code><code class="nohighlight hljs ansi" style="display:block;">SegmentedMean(ψ = Float32[0.0, 0.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_mean(X, bags)</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Float32}:
 1.0  2.5  4.0
 8.0  6.5  5.0</code></pre><div class="admonition is-category-ukn"><header class="admonition-header">Sufficiency of the mean operator</header><div class="admonition-body"><p>In theory, <code>mean</code> aggregation is sufficient for approximation as proven in [<a href="../../references/#Pevny2019">6</a>], but in practice, a combination of multiple operators performes better.</p></div></div><p>The <code>max</code> aggregation is suitable for cases when one instance in the bag may give evidence strong enough to predict the label. On the other side of the spectrum lies the mean aggregation function, which detects well trends identifiable globally over the whole bag.</p><h3 id="Sum-aggregation"><a class="docs-heading-anchor" href="#Sum-aggregation">Sum aggregation</a><a id="Sum-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Sum-aggregation" title="Permalink"></a></h3><p>The last non-parametric operator is <a href="../../api/aggregation/#Mill.SegmentedSum"><code>SegmentedSum</code></a>, defined as:</p><p class="math-container">\[a_{\operatorname{mean}}(\{x_1, \ldots, x_k\}) = \sum_{i = 1}^{k} x_i\]</p><p>and used the same way:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_sum = SegmentedSum(d)</code><code class="nohighlight hljs ansi" style="display:block;">SegmentedSum(ψ = Float32[0.0, 0.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_sum(X, bags)</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Float32}:
 1.0   5.0  4.0
 8.0  13.0  5.0</code></pre><h2 id="Parametric-aggregation"><a class="docs-heading-anchor" href="#Parametric-aggregation">Parametric aggregation</a><a id="Parametric-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-aggregation" title="Permalink"></a></h2><p>Whereas non-parametric aggregations do not use any parameter, parametric aggregations represent an entire class of functions parametrized by one or more real vectors of parameters, which can be even learned during training.</p><h3 id="Log-sum-exp-(LSE)-aggregation"><a class="docs-heading-anchor" href="#Log-sum-exp-(LSE)-aggregation">Log-sum-exp (LSE) aggregation</a><a id="Log-sum-exp-(LSE)-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Log-sum-exp-(LSE)-aggregation" title="Permalink"></a></h3><p><a href="../../api/aggregation/#Mill.SegmentedLSE"><code>SegmentedLSE</code></a> (log-sum-exp) aggregation ([<a href="../../references/#Kraus2015">8</a>]) is parametrized by a vector of positive numbers <span>$\bm{r} \in (\mathbb{R}^+)^d$</span> m that specifies one real parameter for computation in each output dimension:</p><p class="math-container">\[a_{\operatorname{lse}}(\{x_1, \ldots, x_k\}; r) = \frac{1}{r}\log \left(\frac{1}{k} \sum_{i = 1}^{k} \exp({r\cdot x_i})\right)\]</p><p>With different values of <span>$r$</span>, LSE behaves differently and in fact both max and mean operators are limiting cases of LSE. If <span>$r$</span> is very small, the output approaches simple mean, and on the other hand, if <span>$r$</span> is a large number, LSE becomes a smooth approximation of the max function. Naively implementing the definition above may lead to numerical instabilities, however, the <code>Mill</code> implementation is numerically stable.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_lse = SegmentedLSE(d)</code><code class="nohighlight hljs ansi" style="display:block;">SegmentedLSE(ψ = Float32[0.0, 0.0], ρ = Float32[0.249335, -0.0607043])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_lse(X, bags)</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Float32}:
 1.0  2.60039  4.0
 8.0  6.58143  5.0</code></pre><h3 id="p-norm-aggregation"><a class="docs-heading-anchor" href="#p-norm-aggregation"><span>$p$</span>-norm aggregation</a><a id="p-norm-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#p-norm-aggregation" title="Permalink"></a></h3><p>(Normalized) <span>$p$</span>-norm operator ([<a href="../../references/#Gulcehre2014">9</a>]) is parametrized by a vector of real numbers <span>$\bm{p} \in (\mathbb{R}^+)^d$</span>, where <span>$\forall i \in \{1, \ldots ,m \} \colon p_i \geq 1$</span>, and another vector <span>$\bm{c} \in (\mathbb{R}^+)^d$</span>. It is computed with formula:</p><p class="math-container">\[a_{\operatorname{pnorm}}(\{x_1, \ldots, x_k\}; p, c) = \left(\frac{1}{k} \sum_{i = 1}^{k} \vert x_i - c \vert ^ {p} \right)^{\frac{1}{p}}\]</p><p>Again, the <code>Mill</code> implementation is stable.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_pnorm = SegmentedPNorm(d)</code><code class="nohighlight hljs ansi" style="display:block;">SegmentedPNorm(ψ = Float32[0.0, 0.0], ρ = Float32[0.937752, -1.37727], c = Float32[0.0, 0.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_pnorm(X, bags)</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Float32}:
 1.0  2.56238  4.0
 8.0  6.50433  5.0</code></pre><p>Because all parameter constraints are included implicitly (field <code>ρ</code> in both types is a real number that undergoes appropriate transformation before being used), both parametric operators are easy to use and do not require any special treatment. Replacing the definition of aggregation operators while constructing a model (either manually or with <a href="../../api/model_nodes/#Mill.reflectinmodel"><code>reflectinmodel</code></a>) is enough.</p><h3 id="Concatenation"><a class="docs-heading-anchor" href="#Concatenation">Concatenation</a><a id="Concatenation-1"></a><a class="docs-heading-anchor-permalink" href="#Concatenation" title="Permalink"></a></h3><p>To use a concatenation of two or more operators, one can use the <a href="../../api/aggregation/#Mill.AggregationStack"><code>AggregationStack</code></a> constructor:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = AggregationStack(a_mean, a_max)</code><code class="nohighlight hljs ansi" style="display:block;">AggregationStack:
 SegmentedMean(ψ = Float32[0.0, 0.0])
 SegmentedMax(ψ = Float32[0.0, 0.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a(X, bags)</code><code class="nohighlight hljs ansi" style="display:block;">4×3 Matrix{Float32}:
 1.0  2.5  4.0
 8.0  6.5  5.0
 1.0  3.0  4.0
 8.0  7.0  5.0</code></pre><p>For the most common combinations, <code>Mill</code> provides some convenience definitions:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; SegmentedMeanMax(d)</code><code class="nohighlight hljs ansi" style="display:block;">AggregationStack:
 SegmentedMean(ψ = Float32[0.0, 0.0])
 SegmentedMax(ψ = Float32[0.0, 0.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SegmentedPNormLSE(d)</code><code class="nohighlight hljs ansi" style="display:block;">AggregationStack:
 SegmentedPNorm(ψ = Float32[0.0, 0.0], ρ = Float32[-2.59288, -0.492026], c = Float32[0.0, 0.0])
 SegmentedLSE(ψ = Float32[0.0, 0.0], ρ = Float32[1.66734, 1.67681])</code></pre><h2 id="Weighted-aggregation"><a class="docs-heading-anchor" href="#Weighted-aggregation">Weighted aggregation</a><a id="Weighted-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Weighted-aggregation" title="Permalink"></a></h2><p>Sometimes, different instances in the bag are not equally important and contribute to output to a different extent. For instance, this may come in handy when performing importance sampling over very large bags. <a href="../../api/aggregation/#Mill.SegmentedMean"><code>SegmentedMean</code></a> and <a href="../../api/aggregation/#Mill.SegmentedPNorm"><code>SegmentedPNorm</code></a> have definitions taking weights into account:</p><p class="math-container">\[a_{\operatorname{mean}}(\{(x_i, w_i)\}_{i=1}^k) = \frac{1}{\sum_{i=1}^k w_i} \sum_{i = 1}^{k} w_i \cdot x_i\]</p><p class="math-container">\[a_{\operatorname{pnorm}}(\{x_i, w_i\}_{i=1}^k; p, c) = \left(\frac{1}{\sum_{i=1}^k w_i} \sum_{i = 1}^{k} w_i\cdot\vert x_i - c \vert ^ {p} \right)^{\frac{1}{p}}\]</p><p>This is done in <code>Mill</code> by passing an additional parameter:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; w = Float32.([1.0, 0.2, 0.8, 0.5])</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float32}:
 1.0
 0.2
 0.8
 0.5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_mean(X, bags, w)</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Float32}:
 1.0  2.8  4.0
 8.0  6.2  5.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_pnorm(X, bags, w)</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Float32}:
 1.0  2.83521  4.0
 8.0  6.20283  5.0</code></pre><p>For <a href="../../api/aggregation/#Mill.SegmentedMax"><code>SegmentedMax</code></a> and <a href="../../api/aggregation/#Mill.SegmentedLSE"><code>SegmentedLSE</code></a> it is possible to pass in weights, but they are ignored during computation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_max(X, bags, w) == a_max(X, bags)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h3 id="Weighted-nodes"><a class="docs-heading-anchor" href="#Weighted-nodes">Weighted nodes</a><a id="Weighted-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Weighted-nodes" title="Permalink"></a></h3><p><a href="../../api/data_nodes/#Mill.WeightedBagNode"><code>WeightedBagNode</code></a> is used to store instance weights into a dataset. It accepts weights in the constructor:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; wbn = WeightedBagNode(X, bags, w)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">WeightedBagNode</span><span class="sgr90"><span class="sgr3">  3 obs, 176 bytes</span></span>
<span class="sgr34">  ╰── </span>ArrayNode(2×4 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  4 obs, 80 bytes</span></span></code></pre><p>and passes them to aggregation operators:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = reflectinmodel(wbn, d -&gt; Dense(d, 3))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagModel ↦ BagCount([SegmentedMean(3); SegmentedMax(3)]) ↦ Dense(7 =&gt; 3)</span><span class="sgr90"><span class="sgr3">  4 ar </span>⋯</span>
<span class="sgr34">  ╰── </span>ArrayModel(Dense(2 =&gt; 3))<span class="sgr90"><span class="sgr3">  2 arrays, 9 params, 116 bytes</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m(wbn)</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float32}:
 3.76052   3.6409   3.24472
 0.712644  0.87318  0.36645
 4.20341   3.50676  3.27765</code></pre><p>Otherwise, <a href="../../api/data_nodes/#Mill.WeightedBagNode"><code>WeightedBagNode</code></a> behaves exactly like the standard <a href="../../api/data_nodes/#Mill.BagNode"><code>BagNode</code></a>.</p><h3 id="Bag-count"><a class="docs-heading-anchor" href="#Bag-count">Bag count</a><a id="Bag-count-1"></a><a class="docs-heading-anchor-permalink" href="#Bag-count" title="Permalink"></a></h3><p>For some problems, it may be beneficial to use the size of the bag directly and feed it to subsequent layers. To do this, wrap an instance of <a href="../../api/aggregation/#Mill.AbstractAggregation"><code>AbstractAggregation</code></a> or <a href="../../api/aggregation/#Mill.AggregationStack"><code>AggregationStack</code></a> in the <a href="../../api/aggregation/#Mill.BagCount"><code>BagCount</code></a> type.</p><p>In the aggregation phase, bag count appends one more element which stores the bag size to the output after all operators are applied. Furthermore, <code>Mill</code>, performs a mapping <span>$x \mapsto \log(x) + 1$</span> on top of that:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_mean_bc = BagCount(a_mean)</code><code class="nohighlight hljs ansi" style="display:block;">BagCount(SegmentedMean(ψ = Float32[0.0, 0.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_mean_bc(X, bags)</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float32}:
 1.0       2.5      4.0
 8.0       6.5      5.0
 0.693147  1.09861  0.693147</code></pre><p>The matrix now has three rows, the last one storing the size of the bag.</p><p><a href="../reflectin/#Model-reflection">Model reflection</a> adds <a href="../../api/aggregation/#Mill.BagCount"><code>BagCount</code></a> after each aggregation operator by default.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bn = BagNode(X, bags)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagNode</span><span class="sgr90"><span class="sgr3">  3 obs, 112 bytes</span></span>
<span class="sgr34">  ╰── </span>ArrayNode(2×4 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  4 obs, 80 bytes</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bm = reflectinmodel(bn, d -&gt; Dense(d, 3))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagModel ↦ BagCount([SegmentedMean(3); SegmentedMax(3)]) ↦ Dense(7 =&gt; 3)</span><span class="sgr90"><span class="sgr3">  4 ar </span>⋯</span>
<span class="sgr34">  ╰── </span>ArrayModel(Dense(2 =&gt; 3))<span class="sgr90"><span class="sgr3">  2 arrays, 9 params, 116 bytes</span></span></code></pre><p>Note that the <code>bm</code> (sub)model field of the <a href="../../api/data_nodes/#Mill.BagNode"><code>BagNode</code></a> has size of <code>(7, 3)</code>, <code>3</code> for each of two aggregation outputs and <code>1</code> for sizes of bags.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bm(bn)</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float32}:
 -3.99267   -3.3032    -4.15971
 -0.604963  -3.69212   -4.94037
  0.849309  -0.414772  -1.12406</code></pre><h2 id="Default-aggregation-values"><a class="docs-heading-anchor" href="#Default-aggregation-values">Default aggregation values</a><a id="Default-aggregation-values-1"></a><a class="docs-heading-anchor-permalink" href="#Default-aggregation-values" title="Permalink"></a></h2><p>When all aggregation operators are printed, one may notice that all of them store one additional vector <code>ψ</code>. This is a vector of default parameters, initialized to all zeros, that are used for empty bags:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bags = AlignedBags([1:1, 0:-1, 2:3, 0:-1, 4:4])</code><code class="nohighlight hljs ansi" style="display:block;">AlignedBags{Int64}(UnitRange{Int64}[1:1, 0:-1, 2:3, 0:-1, 4:4])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_mean(X, bags)</code><code class="nohighlight hljs ansi" style="display:block;">2×5 Matrix{Float32}:
 1.0  0.0  2.5  0.0  4.0
 8.0  0.0  6.5  0.0  5.0</code></pre><p>That&#39;s why the dimension of input is required in the constructor. See <a href="../missing/#Missing-data">Missing data</a> page for more information.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reflectin/">« Model reflection</a><a class="docs-footer-nextpage" href="../leaf_data/">Data in leaves »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Sunday 2 June 2024 17:52">Sunday 2 June 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
