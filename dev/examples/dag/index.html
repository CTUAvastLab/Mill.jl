<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DAGs · Mill.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Mill.jl logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../motivation/">Motivation</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/nodes/">Nodes</a></li><li><a class="tocitem" href="../../manual/more_on_nodes/">More on nodes</a></li><li><a class="tocitem" href="../../manual/reflectin/">Model reflection</a></li><li><a class="tocitem" href="../../manual/aggregation/">Bag aggregation</a></li><li><a class="tocitem" href="../../manual/leaf_data/">Data in leaves</a></li><li><a class="tocitem" href="../../manual/missing/">Missing data</a></li><li><a class="tocitem" href="../../manual/custom/">Custom nodes</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../musk/musk/">Musk</a></li><li><a class="tocitem" href="../graphs/">GNNs in 16 lines</a></li><li class="is-active"><a class="tocitem" href>DAGs</a></li><li><a class="tocitem" href="../jsons/">Processing JSONs</a></li></ul></li><li><span class="tocitem">External tools</span><ul><li><a class="tocitem" href="../../tools/hierarchical/">HierarchicalUtils.jl</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../citation/">Citation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>DAGs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DAGs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pevnak/Mill.jl/blob/master/docs/src/examples/dag.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DAGs"><a class="docs-heading-anchor" href="#DAGs">DAGs</a><a id="DAGs-1"></a><a class="docs-heading-anchor-permalink" href="#DAGs" title="Permalink"></a></h1><pre><code class="language-julia">using Flux, Zygote, LightGraphs</code></pre><p>Imagine a data/knowledge base represented in a form of a directed acyclic graph (DAG), where a vertex would be modelled based on its parents (and their parents), but not on its descendants. We will make one assumption (common in graphical models) that two children are independent given their parent or, in other words, once we have access to the data or inferred values of the parent, we do not have to inspect its other children.</p><p>For example, in the graph below, when we infer some value for vertex <code>e</code>, we ignore vertices <code>d</code>, <code>g</code>, and <code>h</code>:</p><p><img src="../dag.svg" alt/></p><p>Firstly, we define a new type for our graph that would be able to store a structure of the graph together with vertex features:</p><pre><code class="language-julia">struct DagGraph{G &lt;: SimpleDiGraph,T}
    g::G
    vertex_features::T
end</code></pre><p>Then, we specify a model type:</p><p>Here, <code>m</code> is a function realizing one step of the message passing procedure, and <code>od</code> is output dimension.</p><p>In the course of calculating the value of vertex <code>e</code>, it may happen that for some vertices we will have to compute their value multiple times (for example for <code>c</code>, once when reached from <code>e</code> and once from <code>f</code>). Ideally, we would like to have a cache of already calculated values, which is difficult to do when autodifferentiating with <code>Zygote</code> as it does not support <code>setindex</code> operation. However, since the cache is assigned only once this can be realized through <code>Zygote.buffer</code>. We begin by initializing the cache:</p><pre><code class="language-julia">initcache(g, k) = [Zygote.Buffer(zeros(Float32, k, 1)) for _ in 1:nv(g)]
Zygote.@nograd initcache</code></pre><p>To get the already computed value of a vertex when using the model, we just delegate the question to <code>cache</code> as </p><pre><code class="language-julia">function (model::DagModel)(g::DagGraph, i)
    cache = initcache(g.g, model.od)
    ArrayNode(getfromcache!(cache, g, model, i))
end

(model::DagModel)(g::SimpleDiGraph, vertex_features, i) = model(DagGraph(g, vertex_features), i)</code></pre><p>which means that the <code>getfromcache!</code> will do all the heavy lifting. It turns out that this function just has to check if the value in <code>cache</code> has been already calculated. If not, it will calculate the value (applying <code>model</code> on <code>millvertex!</code>) and freeze the calculated item in cache:</p><pre><code class="language-julia">function getfromcache!(cache, g::DagGraph, model::DagModel, i::Int)
    cache[i].freeze &amp;&amp; return(copy(cache[i]))
    ds = millvertex!(cache, g, model, i)
    cache[i][:] = model.m(ds).data
    return(copy(cache[i]))
end

function getfromcache!(cache, g::DagGraph, model::DagModel, ii::Vector{Int})
    reduce(catobs, [getfromcache!(cache, g, model, i) for i in ii])
end</code></pre><p>And what does <code>millvertex!</code> function do? It just takes the representation of ancestors (from <code>cache</code>) and put them together:</p><pre><code class="language-julia">function millvertex!(cache, g::DagGraph, model::DagModel, i)
    ProductNode((neighbours = millneighbors!(cache, g, model, i),
      vertex = vertex_features[i])
    )
end</code></pre><p>The last missing piece is <code>millneighbors!</code> definition:</p><pre><code class="language-julia">function millneighbors!(cache, g::DagGraph, model::DagModel, ii::Vector{Int})
    isempty(ii) &amp;&amp; return(BagNode(missing, [0:-1]))
    xs = [getfromcache!(cache, g, model, i) for i in  ii]
    BagNode(ArrayNode(reduce(catobs, xs)), [1:length(xs)])
end

millneighbors!(cache, g::DagGraph, model::DagModel, i::Int) = millneighbors!(cache, g, model, inneighbors(g.g, i))

Zygote.@nograd LightGraphs.inneighbors</code></pre><p>Note that this recursive approach is not the most efficient way to implement this. It would be better to spent a little time with graphs to identify sets of vertices that can be processed in parallel and for which all ancestors are known. But this was a fun little exercise.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../graphs/">« GNNs in 16 lines</a><a class="docs-footer-nextpage" href="../jsons/">Processing JSONs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 2 February 2021 20:15">Tuesday 2 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
