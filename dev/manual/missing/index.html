<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Missing data · Mill.jl</title><meta name="title" content="Missing data · Mill.jl"/><meta property="og:title" content="Missing data · Mill.jl"/><meta property="twitter:title" content="Missing data · Mill.jl"/><meta name="description" content="Documentation for Mill.jl."/><meta property="og:description" content="Documentation for Mill.jl."/><meta property="twitter:description" content="Documentation for Mill.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Mill.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Mill.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../motivation/">Motivation</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../nodes/">Nodes</a></li><li><a class="tocitem" href="../more_on_nodes/">More on nodes</a></li><li><a class="tocitem" href="../reflectin/">Model reflection</a></li><li><a class="tocitem" href="../aggregation/">Bag aggregation</a></li><li><a class="tocitem" href="../leaf_data/">Data in leaves</a></li><li class="is-active"><a class="tocitem" href>Missing data</a><ul class="internal"><li><a class="tocitem" href="#Empty-bags"><span>Empty bags</span></a></li><li><a class="tocitem" href="#Post-imputing"><span>Post imputing</span></a></li><li><a class="tocitem" href="#Pre-imputing"><span>Pre imputing</span></a></li><li><a class="tocitem" href="#Model-reflection-with-missing-values"><span>Model reflection with missing values</span></a></li></ul></li><li><a class="tocitem" href="../custom/">Custom nodes</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/musk/musk/">Musk</a></li><li><a class="tocitem" href="../../examples/gnn/">GNNs in 16 lines</a></li><li><a class="tocitem" href="../../examples/dag/">DAGs</a></li><li><a class="tocitem" href="../../examples/jsons/">Processing JSONs</a></li></ul></li><li><span class="tocitem">External tools</span><ul><li><a class="tocitem" href="../../tools/hierarchical/">HierarchicalUtils.jl</a></li></ul></li><li><span class="tocitem">Public API</span><ul><li><a class="tocitem" href="../../api/aggregation/">Aggregation</a></li><li><a class="tocitem" href="../../api/bags/">Bags</a></li><li><a class="tocitem" href="../../api/data_nodes/">Data nodes</a></li><li><a class="tocitem" href="../../api/model_nodes/">Model nodes</a></li><li><a class="tocitem" href="../../api/special_arrays/">Special Arrays</a></li><li><a class="tocitem" href="../../api/switches/">Switches</a></li><li><a class="tocitem" href="../../api/utilities/">Utilities</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../citation/">Citation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Missing data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Missing data</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CTUAvastLab/Mill.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CTUAvastLab/Mill.jl/blob/master/docs/src/manual/missing.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Missing-data"><a class="docs-heading-anchor" href="#Missing-data">Missing data</a><a id="Missing-data-1"></a><a class="docs-heading-anchor-permalink" href="#Missing-data" title="Permalink"></a></h1><p>One detail that was left out so far is how <a href="https://github.com/CTUAvastLab/Mill.jl"><code>Mill.jl</code></a> handles incomplete or missing data. This phenomenon is nowadays ubiquitous in many data sources and occurs due to:</p><ul><li>a high price of obtaining a (part of) observation</li><li>information being unreachable due to privacy reasons</li><li>a gradual change in the definition of data being gathered</li><li>a faulty collection process</li></ul><p>and many other possible reasons. At the same time, it is wasteful to throw away the incomplete observations altogether. Thanks to the hierarchical structure of both samples and models, we can still process samples with missing information fragments at various levels of abstraction. Problems of this type can be categorized into 3 not necessarily separate types:</p><ol><li>Missing parts of raw-data in a leaf <a href="../../api/data_nodes/#Mill.ArrayNode"><code>ArrayNode</code></a></li><li>Empty bags with no instances in a <a href="../../api/data_nodes/#Mill.BagNode"><code>BagNode</code></a></li><li>And entire key missing in a <a href="../../api/data_nodes/#Mill.ProductNode"><code>ProductNode</code></a></li></ol><p>At the moment, <code>Mill</code> is capable of handling the first two cases. The solution always involves an additional vector of parameters (denoted always by <code>ψ</code>) that are used during the model evaluation to substitute the missing values. Parameters <code>ψ</code> can be either fixed or learned during training. Everything is done automatically.</p><h2 id="Empty-bags"><a class="docs-heading-anchor" href="#Empty-bags">Empty bags</a><a id="Empty-bags-1"></a><a class="docs-heading-anchor-permalink" href="#Empty-bags" title="Permalink"></a></h2><p>It may happen that some bags in the datasets are empty by definition or no associated instances were obtained during data collection. Recall, that an empty bag is specified as empty range <code>0:-1</code> in case of <a href="../../api/bags/#Mill.AlignedBags"><code>AlignedBags</code></a> and as an empty vector <code>Int[]</code> when <a href="../../api/bags/#Mill.ScatteredBags"><code>ScatteredBags</code></a> are used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; empty_bags_1 = AlignedBags([1:2, 0:-1, 3:5, 0:-1])</code><code class="nohighlight hljs ansi" style="display:block;">AlignedBags{Int64}(UnitRange{Int64}[1:2, 0:-1, 3:5, 0:-1])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; empty_bags_2 = ScatteredBags([[1, 2], Int[], [3, 4, 5], Int[]])</code><code class="nohighlight hljs ansi" style="display:block;">ScatteredBags{Int64}([[1, 2], Int64[], [3, 4, 5], Int64[]])</code></pre><p>To obtain the vector representation for a bag, be it for dircetly predicting some value or using it to represent some higher-level structures, we need to deal with these empty bags. This is done in <a href="../aggregation/#Bag-aggregation">Bag aggregation</a>. Each <a href="../../api/aggregation/#Mill.AbstractAggregation"><code>AbstractAggregation</code></a> operator carries a vector of parameters <code>ψ</code>, initialized to zeros upon creation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = SegmentedSumMax(2)</code><code class="nohighlight hljs ansi" style="display:block;">AggregationStack:
 SegmentedSum(ψ = Float32[0.0, 0.0])
 SegmentedMax(ψ = Float32[0.0, 0.0])</code></pre><p>When we evaluate any <a href="../../api/model_nodes/#Mill.BagModel"><code>BagModel</code></a>, these values are used to compute output for empty bags instead of the aggregation itself. See the demo below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; an = ArrayNode(randn(Float32, 2, 5))</code><code class="nohighlight hljs ansi" style="display:block;">2×5 ArrayNode{Matrix{Float32}, Nothing}:
  0.6467423  0.31947362  -0.92877233  1.0960424    1.049499
 -1.0114008  1.3934115    0.38794893  0.62901175  -2.0970821</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ds = BagNode(an, empty_bags_2)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagNode</span><span class="sgr90"><span class="sgr3">  4 obs, 296 bytes</span></span>
<span class="sgr34">  ╰── </span>ArrayNode(2×5 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  5 obs, 88 bytes</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = BagModel(identity, a, identity)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagModel ↦ [SegmentedSum(2); SegmentedMax(2)] ↦ identity</span><span class="sgr90"><span class="sgr3">  2 arrays, 4 params ( </span>⋯</span>
<span class="sgr34">  ╰── </span>ArrayModel(identity)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m(ds)</code><code class="nohighlight hljs ansi" style="display:block;">4×4 Matrix{Float32}:
 0.966216  0.0   1.21677   0.0
 0.382011  0.0  -1.08012   0.0
 0.646742  0.0   1.09604   0.0
 1.39341   0.0   0.629012  0.0</code></pre><p>Vector <code>ψ</code> is learnable and therefore after training will contain a suitable representation of an empty bag for the given problem.</p><p>When a <a href="../../api/data_nodes/#Mill.BagNode"><code>BagNode</code></a> is entirely empty, it can be constructed with <code>missing</code> instead of a matrix wrapped in an <a href="../../api/data_nodes/#Mill.ArrayNode"><code>ArrayNode</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bn1 = BagNode(ArrayNode(rand(3, 4)), [1:4])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagNode</span><span class="sgr90"><span class="sgr3">  1 obs, 80 bytes</span></span>
<span class="sgr34">  ╰── </span>ArrayNode(3×4 Array with Float64 elements)<span class="sgr90"><span class="sgr3">  4 obs, 144 bytes</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bn2 = BagNode(missing, [0:-1])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagNode</span><span class="sgr90"><span class="sgr3">  1 obs, 72 bytes</span></span>
<span class="sgr34">  ╰── </span>∅</code></pre><p>and everything will work as expected. For example, we can concatenate these two:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = catobs(bn1, bn2)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagNode</span><span class="sgr90"><span class="sgr3">  2 obs, 96 bytes</span></span>
<span class="sgr34">  ╰── </span>ArrayNode(3×4 Array with Float64 elements)<span class="sgr90"><span class="sgr3">  4 obs, 144 bytes</span></span></code></pre><p>Notice, that the resulting <a href="../../api/data_nodes/#Mill.ArrayNode"><code>ArrayNode</code></a> has still the same dimension as <a href="../../api/data_nodes/#Mill.ArrayNode"><code>ArrayNode</code></a> inside <code>bn1</code>. The emptiness of <code>bn2</code> is stored in <code>bags</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x.bags</code><code class="nohighlight hljs ansi" style="display:block;">AlignedBags{Int64}(UnitRange{Int64}[1:4, 0:-1])</code></pre><p>The second element <a href="../../api/data_nodes/#Mill.BagNode"><code>BagNode</code></a> can be obtained again by indexing:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bn1 == x[2]</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p>Even though this approach of using <code>missing</code> for <code>data</code> field in <a href="../../api/data_nodes/#Mill.BagNode"><code>BagNode</code></a>s is the most accurate from the semantic point of view, it may cause excessive compilation, as the types will be different. Therefore, if this happens in multiple places in the sample tree, it may be better to instead use an empty matrix for type consistency:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; BagNode(ArrayNode(zeros(3, 0)), [0:-1])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagNode</span><span class="sgr90"><span class="sgr3">  1 obs, 80 bytes</span></span>
<span class="sgr34">  ╰── </span>ArrayNode(3×0 Array with Float64 elements)<span class="sgr90"><span class="sgr3">  0 obs, 48 bytes</span></span></code></pre><p>How indexing behaves with respect to this issue depends on a global switch (off by default) and  can be changed with the <a href="../../api/switches/#Mill.emptyismissing!"><code>Mill.emptyismissing!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = BagNode(ArrayNode(rand(3, 2)), [1:2, 0:-1, 0:-1])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagNode</span><span class="sgr90"><span class="sgr3">  3 obs, 112 bytes</span></span>
<span class="sgr34">  ╰── </span>ArrayNode(3×2 Array with Float64 elements)<span class="sgr90"><span class="sgr3">  2 obs, 96 bytes</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a[2:3] |&gt; Mill.data</code><code class="nohighlight hljs ansi" style="display:block;">3×0 ArrayNode{Matrix{Float64}, Nothing}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Mill.emptyismissing!(true)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a[2:3] |&gt; Mill.data</code><code class="nohighlight hljs ansi" style="display:block;">missing</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; missing</code><code class="nohighlight hljs ansi" style="display:block;">missing</code></pre><h2 id="Post-imputing"><a class="docs-heading-anchor" href="#Post-imputing">Post imputing</a><a id="Post-imputing-1"></a><a class="docs-heading-anchor-permalink" href="#Post-imputing" title="Permalink"></a></h2><p>Storing missing strings in <a href="../../api/special_arrays/#Mill.NGramMatrix"><code>NGramMatrix</code></a> is straightforward:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; missing_ngrams = NGramMatrix([&quot;foo&quot;, missing, &quot;bar&quot;], 3, 256, 5)</code><code class="nohighlight hljs ansi" style="display:block;">5×3 NGramMatrix{Union{Missing, String}, Vector{Union{Missing, String}}, Union{Missing, Int64}}:
 &quot;foo&quot;
 missing
 &quot;bar&quot;</code></pre><p>When some values of categorical variables are missing, <code>Mill</code> defines a new type for representation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; missing_categorical = maybehotbatch([missing, 2, missing], 1:5)</code><code class="nohighlight hljs ansi" style="display:block;">5×3 MaybeHotMatrix with eltype Union{Missing, Bool}:
 missing    ⋅    missing
 missing   true  missing
 missing    ⋅    missing
 missing    ⋅    missing
 missing    ⋅    missing</code></pre><p><a href="../../api/special_arrays/#Mill.MaybeHotMatrix"><code>MaybeHotMatrix</code></a> behaves similarly as <code>OneHotMatrix</code> from <a href="https://fluxml.ai"><code>Flux.jl</code></a>, but it supports possibly <code>missing</code> values. In case when no values are <code>missing</code> it looks exactly like <code>OneHotMatrix</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; maybehotbatch([5, 2, 1], 1:5)</code><code class="nohighlight hljs ansi" style="display:block;">5×3 MaybeHotMatrix with eltype Bool:
 ⋅  ⋅  1
 ⋅  1  ⋅
 ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅
 1  ⋅  ⋅</code></pre><p><a href="../../api/special_arrays/#Mill.MaybeHotMatrix"><code>MaybeHotMatrix</code></a> behaves like <code>AbstractMatrix</code> and supports left multiplication again:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; missing_categorical::AbstractMatrix{Union{Bool, Missing}}</code><code class="nohighlight hljs ansi" style="display:block;">5×3 MaybeHotMatrix with eltype Union{Missing, Bool}:
 missing    ⋅    missing
 missing   true  missing
 missing    ⋅    missing
 missing    ⋅    missing
 missing    ⋅    missing</code></pre><p>However, multiplying these matrices with <code>missing</code> data leads into <code>missing</code> data in the output.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; W = rand(2, 5)</code><code class="nohighlight hljs ansi" style="display:block;">2×5 Matrix{Float64}:
 0.880801  0.52829   0.567866  0.657427  0.839293
 0.45467   0.255719  0.657579  0.617     0.533037</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W * missing_ngrams</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Union{Missing, Float64}}:
 3.69705  missing  3.69512
 2.35568  missing  2.8359</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W * missing_categorical</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Union{Missing, Float64}}:
 missing  0.52829   missing
 missing  0.255719  missing</code></pre><p>Consequently, gradient can&#39;t be computed and any model can&#39;t be trained.</p><div class="admonition is-category-ukn"><header class="admonition-header">Model debugging</header><div class="admonition-body"><p>Flux <code>gradient</code> call returns an error like <code>Output should be scalar; gradients are not defined for output missing</code> when attempted on <code>missing</code> result. In a similar fashion as having <code>NaN</code>s in a model, this signifies that some <code>missing</code> input is not treated anywhere in the model and it propagates up. Generally speaking, it is recommended to deal with missing values as soon as possible (on the leaf level) so that they do not propagate and cause type instabilities.</p></div></div><p><a href="../../api/special_arrays/#Mill.PostImputingMatrix"><code>PostImputingMatrix</code></a> is a solution for this. It can be constructed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = PostImputingMatrix(W)</code><code class="nohighlight hljs ansi" style="display:block;">2×5 PostImputingMatrix{Float64, Matrix{Float64}, Vector{Float64}}:
W:
 0.880801  0.52829   0.567866  0.657427  0.839293
 0.45467   0.255719  0.657579  0.617     0.533037

ψ:
 0.0
 0.0</code></pre><p>Matrix <code>W</code> is stored inside and <code>A</code> creates one vector of parameters <code>ψ</code> of length <code>size(W, 1)</code> on top of that. Suddenly, multiplication automagically works:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A * missing_ngrams</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Float64}:
 3.69705  0.0  3.69512
 2.35568  0.0  2.8359</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A * missing_categorical</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Float64}:
 0.0  0.52829   0.0
 0.0  0.255719  0.0</code></pre><p>What happens under the hood is that whenever <code>A</code> encounters a <code>missing</code> column in the matrix, it fills in values from <code>ψ</code> <strong>after</strong> the multiplication is performed (effectively replacing all <code>missing</code> values in the result of multiplying with <code>W</code>, but implemented more efficiently). Vector <code>ψ</code> can be learned during training as well and everything works out of the box.</p><h2 id="Pre-imputing"><a class="docs-heading-anchor" href="#Pre-imputing">Pre imputing</a><a id="Pre-imputing-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-imputing" title="Permalink"></a></h2><p>If we have to deal with inputs where some elements of input matrix are <code>missing</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; X = [missing 1 2; 3 missing missing]</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Union{Missing, Int64}}:
  missing  1         2
 3          missing   missing</code></pre><p>we can make use of <a href="../../api/special_arrays/#Mill.PreImputingMatrix"><code>PreImputingMatrix</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; W = rand(1:2, 3, 2)</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Int64}:
 1  1
 1  2
 2  2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = PreImputingMatrix(W)</code><code class="nohighlight hljs ansi" style="display:block;">3×2 PreImputingMatrix{Int64, Matrix{Int64}, Vector{Int64}}:
W:
 1  1
 1  2
 2  2

ψ:
 0  0</code></pre><p>As opposed to <a href="../../api/special_arrays/#Mill.PostImputingMatrix"><code>PostImputingMatrix</code></a>, <code>A</code> now stores a vector of values <code>ψ</code> with length <code>size(W, 2)</code>. When we use it for multiplication:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A * X</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Int64}:
 3  1  2
 6  1  2
 6  2  4</code></pre><p>what happens is that when we perform a dot product of a row of <code>A</code> and a column of <code>X</code>, we first fill in values from <code>ψ</code> into the column <strong>before</strong> the multiplication is performed. Again, it is possible to compute gradients with respect to all three of <code>W</code>, <code>ψ</code> and <code>X</code> and therefore learn the appropriate default values in <code>ψ</code> from the data:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; gradient((A, X) -&gt; sum(A * X), A, X)</code><code class="nohighlight hljs ansi" style="display:block;">((W = [3 3; 3 3; 3 3], ψ = [4, 10]), Real[0 4.0 4.0; 5.0 0 0])</code></pre><h2 id="Model-reflection-with-missing-values"><a class="docs-heading-anchor" href="#Model-reflection-with-missing-values">Model reflection with missing values</a><a id="Model-reflection-with-missing-values-1"></a><a class="docs-heading-anchor-permalink" href="#Model-reflection-with-missing-values" title="Permalink"></a></h2><p>Model reflection takes <code>missing</code> values and types into account and creates appropriate (sub)models to handle them:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ds = ProductNode((missing_ngrams, missing_categorical, X))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">ProductNode</span><span class="sgr90"><span class="sgr3">  3 obs, 56 bytes</span></span>
<span class="sgr34">  ├── </span>ArrayNode(5×3 NGramMatrix with Union{Missing, Int64} elements)<span class="sgr90"><span class="sgr3">  3 obs, 1 </span>⋯</span>
<span class="sgr34">  ├── </span>ArrayNode(5×3 MaybeHotMatrix with Union{Missing, Bool} elements)<span class="sgr90"><span class="sgr3">  3 obs, </span>⋯</span>
<span class="sgr34">  ╰── </span>ArrayNode(2×3 Array with Union{Missing, Int64} elements)<span class="sgr90"><span class="sgr3">  3 obs, 102 byt </span>⋯</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = reflectinmodel(ds)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">ProductModel ↦ Dense(30 =&gt; 10)</span><span class="sgr90"><span class="sgr3">  2 arrays, 310 params, 1.289 KiB</span></span>
<span class="sgr34">  ├── </span>ArrayModel([postimputing]Dense(5 =&gt; 10))<span class="sgr90"><span class="sgr3">  3 arrays, 70 params, 400 bytes</span></span>
<span class="sgr34">  ├── </span>ArrayModel([postimputing]Dense(5 =&gt; 10))<span class="sgr90"><span class="sgr3">  3 arrays, 70 params, 400 bytes</span></span>
<span class="sgr34">  ╰── </span>ArrayModel([preimputing]Dense(2 =&gt; 10))<span class="sgr90"><span class="sgr3">  3 arrays, 32 params, 248 bytes</span></span></code></pre><p>Here, <code>[pre_imputing]Dense</code> and <code>[post_imputing]Dense</code> are standard dense layers with a special matrix inside:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dense = m.ms[1].m; typeof(dense.weight)</code><code class="nohighlight hljs ansi" style="display:block;">PostImputingMatrix{Float32, Matrix{Float32}, Vector{Float32}}</code></pre><p>Inside <code>Mill</code> we add a special definition <code>Base.show</code> for these types for compact printing.</p><p>The <a href="../../api/model_nodes/#Mill.reflectinmodel"><code>reflectinmodel</code></a> method use types to determine whether imputing is needed or not. Compare the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; reflectinmodel(ArrayNode(randn(Float32, 2, 3)))</code><code class="nohighlight hljs ansi" style="display:block;">ArrayModel(Dense(2 =&gt; 10))<span class="sgr90"><span class="sgr3">  2 arrays, 30 params, 200 bytes</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reflectinmodel(ArrayNode([1.0f0 2.0f0 missing; 4.0f0 missing missing]))</code><code class="nohighlight hljs ansi" style="display:block;">ArrayModel([preimputing]Dense(2 =&gt; 10))<span class="sgr90"><span class="sgr3">  3 arrays, 32 params, 248 bytes</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reflectinmodel(ArrayNode(Matrix{Union{Missing, Float32}}(randn(2, 3))))</code><code class="nohighlight hljs ansi" style="display:block;">ArrayModel([preimputing]Dense(2 =&gt; 10))<span class="sgr90"><span class="sgr3">  3 arrays, 32 params, 248 bytes</span></span></code></pre><p>In the last case, the imputing type is returned even though there is no <code>missing</code> element in the matrix. Of course, the same applies to <a href="../../api/special_arrays/#Mill.MaybeHotVector"><code>MaybeHotVector</code></a>, <a href="../../api/special_arrays/#Mill.MaybeHotMatrix"><code>MaybeHotMatrix</code></a> and <a href="../../api/special_arrays/#Mill.NGramMatrix"><code>NGramMatrix</code></a>. This way, we can signify that even though there are no missing values in the available sample, we expect them to appear in the future and want our model compatible. If it is hard to determine this in advance a safe bet is to make all leaves in the model. The performance will not suffer because imputing types are as fast as their non-imputing counterparts on data not containing <code>missing</code> values and the only tradeoff is a slight increase in the number of parameters, some of which may never be used.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../leaf_data/">« Data in leaves</a><a class="docs-footer-nextpage" href="../custom/">Custom nodes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Sunday 2 June 2024 17:38">Sunday 2 June 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
