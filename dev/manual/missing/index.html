<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Missing data · Mill.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Mill.jl logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../motivation/">Motivation</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../nodes/">Nodes</a></li><li><a class="tocitem" href="../more_on_nodes/">More on nodes</a></li><li><a class="tocitem" href="../reflectin/">Model reflection</a></li><li><a class="tocitem" href="../aggregation/">Bag aggregation</a></li><li><a class="tocitem" href="../leaf_data/">Data in leaves</a></li><li class="is-active"><a class="tocitem" href>Missing data</a><ul class="internal"><li><a class="tocitem" href="#Empty-bags"><span>Empty bags</span></a></li><li><a class="tocitem" href="#PostImputingMatrix"><span><code>PostImputingMatrix</code></span></a></li><li><a class="tocitem" href="#PreImputingMatrix"><span><code>PreImputingMatrix</code></span></a></li><li><a class="tocitem" href="#Model-reflection-with-missing-values"><span>Model reflection with missing values</span></a></li></ul></li><li><a class="tocitem" href="../custom/">Custom nodes</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/musk/musk/">Musk</a></li><li><a class="tocitem" href="../../examples/graphs/">GNNs in 16 lines</a></li><li><a class="tocitem" href="../../examples/dag/">DAGs</a></li><li><a class="tocitem" href="../../examples/jsons/">Processing JSONs</a></li></ul></li><li><span class="tocitem">External tools</span><ul><li><a class="tocitem" href="../../tools/hierarchical/">HierarchicalUtils.jl</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../citation/">Citation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Missing data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Missing data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pevnak/Mill.jl/blob/master/docs/src/manual/missing.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Missing-data"><a class="docs-heading-anchor" href="#Missing-data">Missing data</a><a id="Missing-data-1"></a><a class="docs-heading-anchor-permalink" href="#Missing-data" title="Permalink"></a></h1><p>One detail that was left out so far is how <code>Mill.jl</code> handles incomplete or missing data. This phenomenon is nowadays ubiquitous in many data sources and occurs due to:</p><ul><li>a high price of obtaining a (part of) observation</li><li>information being unreachable due to privacy reasons</li><li>a gradual change in the definition of data being gathered</li><li>a faulty collection process</li></ul><p>and many other possible reasons. At the same time, it is wasteful to throw away the incomplete observations altogether. Thanks to the hierarchical structure of both samples and models, we can still process samples with missing information fragments at various levels of abstraction. Problems of this type can be categorized into 3 not necessarily separate types:</p><ol><li>Missing parts of raw-data in a leaf <code>ArrayNode</code></li><li>Empty bags with no instances in a <code>BagNode</code></li><li>And entire key missing in a <code>ProductNode</code></li></ol><p>At the moment, <code>Mill.jl</code> is capable of handling the first two cases. The solution always involves an additional vector of parameters (denoted always by <code>ψ</code>) that are used during the model evaluation to substitute the missing values. Parameters <code>ψ</code> can be either fixed or learned during training. Everything is done automatically.</p><h2 id="Empty-bags"><a class="docs-heading-anchor" href="#Empty-bags">Empty bags</a><a id="Empty-bags-1"></a><a class="docs-heading-anchor-permalink" href="#Empty-bags" title="Permalink"></a></h2><p>It may happen that some bags in the datasets are empty by definition or no associated instances were obtained during data collection. Recall, that an empty bag is specified as empty range <code>0:-1</code> in case of <code>AlignedBags</code> and as an empty vector <code>[]</code> when <code>ScatteredBags</code> are used:</p><pre><code class="language-julia-repl">julia&gt; empty_bags_1 = AlignedBags([1:2, 0:-1, 3:5, 0:-1])
AlignedBags{Int64}(UnitRange{Int64}[1:2, 0:-1, 3:5, 0:-1])

julia&gt; empty_bags_2 = ScatteredBags([[1, 2], [], [3, 4, 5], []])
ERROR: MethodError: no method matching ScatteredBags(::Array{Array{Any,1},1})
Closest candidates are:
  ScatteredBags() at /home/runner/work/Mill.jl/Mill.jl/src/bags.jl:130
  ScatteredBags(!Matched::Array{Array{T,1},1}) where T&lt;:Integer at /home/runner/work/Mill.jl/Mill.jl/src/bags.jl:113
  ScatteredBags(!Matched::Array{T,1}) where T&lt;:Integer at /home/runner/work/Mill.jl/Mill.jl/src/bags.jl:143</code></pre><p>To obtain the vector representation for a bag, be it for dircetly predicting some value or using it to represent some higher-level structures, we need to deal with these empty bags. This is done in <a href="manual/@ref"><code>Bag aggregation</code></a>. Each <code>AggregationOperator</code> carries a vector of parameters <code>ψ</code>, initialized to zeros upon creation:</p><pre><code class="language-julia-repl">julia&gt; a = SegmentedSumMax(2)
Aggregation{Float32}:
 SegmentedSum(ψ = Float32[0.0, 0.0])
 SegmentedMax(ψ = Float32[0.0, 0.0])</code></pre><p>When we evaluate any <code>BagModel</code>, these values are used to compute output for empty bags instead of the aggregation itself. See the demo below:</p><pre><code class="language-julia-repl">julia&gt; an = ArrayNode(randn(Float32, 2, 5))
2×5 ArrayNode{Array{Float32,2},Nothing}:
 -0.39997643   1.5502496   0.5901503   0.665779    0.57569706
  1.0984185   -0.31769887  1.2546335  -0.9248883  -1.2150733

julia&gt; ds = BagNode(an, empty_bags_2)
ERROR: UndefVarError: empty_bags_2 not defined

julia&gt; m = BagModel(identity, a, identity)
BagModel … ↦ ⟨SegmentedSum(2), SegmentedMax(2)⟩ ↦ ArrayModel(identity)
  └── ArrayModel(identity)

julia&gt; m(ds)
ERROR: UndefVarError: ds not defined</code></pre><p>Vector <code>ψ</code> is learnable and therefore after training will contain a suitable representation of an empty bag for the given problem.</p><p>When a <code>BagNode</code> is entirely empty, it can be constructed with <code>missing</code> instead of a matrix wrapped in an <code>ArrayNode</code>:</p><pre><code class="language-julia-repl">julia&gt; bn1 = BagNode(ArrayNode(rand(3, 4)), [1:4])
BagNode with 1 obs
  └── ArrayNode(3×4 Array with Float64 elements) with 4 obs

julia&gt; bn2 = BagNode(missing, [0:-1])
BagNode with 1 obs
  └── ∅</code></pre><p>and everything will work as expected. For example, we can concatenate these two:</p><pre><code class="language-julia-repl">julia&gt; x = catobs(bn1, bn2)
BagNode with 2 obs
  └── ArrayNode(3×4 Array with Float64 elements) with 4 obs</code></pre><p>Notice, that the resulting <code>ArrayNode</code> has still the same dimension as <code>ArrayNode</code> inside <code>bn1</code>. The emptiness of <code>bn2</code> is stored in <code>bags</code>:</p><pre><code class="language-julia-repl">julia&gt; x.bags
AlignedBags{Int64}(UnitRange{Int64}[1:4, 0:-1])</code></pre><p>The second element <code>BagNode</code> can be obtained again by indexing:</p><pre><code class="language-julia-repl">julia&gt; bn1 == x[2]
false</code></pre><p>Even though this approach of using <code>missing</code> for <code>data</code> field in <code>BagNodes</code> is the most accurate from the semantic point of view, it may cause excessive compilation, as the types will be different. Therefore, if this happens in multiple places in the sample tree, it may be better to instead use an empty matrix for type consistency:</p><pre><code class="language-julia-repl">julia&gt; BagNode(ArrayNode(zeros(3, 0)), [0:-1])
BagNode with 1 obs
  └── ArrayNode(3×0 Array with Float64 elements) with 0 obs</code></pre><p>How indexing behaves with respect to this issue depends on a global switch (off by default) and  can be changed with the <a href="../../api/#Mill.emptyismissing!"><code>Mill.emptyismissing!</code></a> function:</p><pre><code class="language-julia-repl">julia&gt; a = BagNode(ArrayNode(rand(3, 2)), [1:2, 0:-1, 0:-1])
BagNode with 3 obs
  └── ArrayNode(3×2 Array with Float64 elements) with 2 obs

julia&gt; a[2:3].data
3×0 ArrayNode{Array{Float64,2},Nothing}

julia&gt; Mill.emptyismissing!(true)
true

julia&gt; a[2:3].data
missing

julia&gt; missing
missing</code></pre><h2 id="PostImputingMatrix"><a class="docs-heading-anchor" href="#PostImputingMatrix"><code>PostImputingMatrix</code></a><a id="PostImputingMatrix-1"></a><a class="docs-heading-anchor-permalink" href="#PostImputingMatrix" title="Permalink"></a></h2><p>Storing missing strings in <code>NGramMatrix</code> is straightforward:</p><pre><code class="language-julia-repl">julia&gt; missing_ngrams = NGramMatrix([&quot;foo&quot;, missing, &quot;bar&quot;], 3, 256, 5)
5×3 NGramMatrix{Union{Missing, String},Union{Missing, Int64}}:
 &quot;foo&quot;
 missing
 &quot;bar&quot;</code></pre><p>When some values of categorical variables are missing, <code>Mill.jl</code> defines a new type for representation:</p><pre><code class="language-julia-repl">julia&gt; missing_categorical = maybehotbatch([missing, 2, missing], 1:5)
5×3 MaybeHotMatrix{Union{Missing, Int64},Int64,Union{Missing, Bool}}:
 missing  false  missing
 missing   true  missing
 missing  false  missing
 missing  false  missing
 missing  false  missing</code></pre><p><code>MaybeHotMatrix</code> behaves similarly as <code>OneHotMatrix</code> from <a href="https://fluxml.ai"><code>Flux.jl</code></a>, but it supports possibly <code>missing</code> values. In case when no values are <code>missing</code> it behaves exactly like <code>OneHotMatrix</code>:</p><pre><code class="language-julia-repl">julia&gt; maybehotbatch([5, 2, 1], 1:5)
5×3 MaybeHotMatrix{Int64,Int64,Bool}:
 0  0  1
 0  1  0
 0  0  0
 0  0  0
 1  0  0</code></pre><p><code>MaybeHotMatrix</code> behaves like <code>AbstractMatrix</code> and supports left multiplication again:</p><pre><code class="language-julia-repl">julia&gt; missing_categorical::AbstractMatrix{Union{Bool, Missing}}
5×3 MaybeHotMatrix{Union{Missing, Int64},Int64,Union{Missing, Bool}}:
 missing  false  missing
 missing   true  missing
 missing  false  missing
 missing  false  missing
 missing  false  missing</code></pre><p>However, multiplying these matrices with <code>missing</code> data leads into <code>missing</code> data in the output.</p><pre><code class="language-julia-repl">julia&gt; W = rand(2, 5)
2×5 Array{Float64,2}:
 0.674501  0.073195  0.0384294  0.786678   0.745909
 0.704423  0.743738  0.72945    0.0694917  0.598985

julia&gt; W * missing_ngrams
2×3 Array{Union{Missing, Float64},2}:
 1.60523  missing  1.64187
 3.52034  missing  3.40061

julia&gt; W * missing_categorical
2×3 Array{Union{Missing, Float64},2}:
 missing  0.073195  missing
 missing  0.743738  missing</code></pre><p>Consequently, gradient can&#39;t be computed and any model can&#39;t be trained.</p><div class="admonition is-category-ukn"><header class="admonition-header">Model debugging</header><div class="admonition-body"><p>Flux <code>gradient</code> call returns an error like <code>Output should be scalar; gradients are not defined for output missing</code> when attempted on <code>missing</code> result. In a similar fashion as having <code>NaN</code>s in a model, this signifies that some <code>missing</code> input is not treated anywhere in the model and it propagates up. Generally speaking, it is recommended to deal with missing values as soon as possible (on the leaf level) so that they do not propagate and cause type instabilities.</p></div></div><p><code>PostImputingMatrix</code> is a solution for this. It can be constructed as follows:</p><pre><code class="language-julia-repl">julia&gt; A = PostImputingMatrix(W)
2×5 PostImputingMatrix{Float64,Array{Float64,2},Array{Float64,1}}:
W:
 0.674501  0.073195  0.0384294  0.786678   0.745909
 0.704423  0.743738  0.72945    0.0694917  0.598985

ψ:
 0.0
 0.0</code></pre><p>Matrix <code>W</code> is stored inside and <code>A</code> creates one vector of parameters <code>ψ</code> of length <code>size(W, 1)</code> on top of that. Suddenly, multiplication automagically works:</p><pre><code class="language-julia-repl">julia&gt; A * missing_ngrams
2×3 Array{Float64,2}:
 1.60523  0.0  1.64187
 3.52034  0.0  3.40061

julia&gt; A * missing_categorical
2×3 Array{Float64,2}:
 0.0  0.073195  0.0
 0.0  0.743738  0.0</code></pre><p>What happens under the hood is that whenever <code>A</code> encounters a <code>missing</code> column in the matrix, it fills in values from <code>ψ</code> <strong>after</strong> the multiplication is performed (effectively replacing all <code>missing</code> values in the result of multiplying with <code>W</code>, but implemented more efficiently). Vector <code>ψ</code> can be learned during training as well and everything works out of the box.</p><h2 id="PreImputingMatrix"><a class="docs-heading-anchor" href="#PreImputingMatrix"><code>PreImputingMatrix</code></a><a id="PreImputingMatrix-1"></a><a class="docs-heading-anchor-permalink" href="#PreImputingMatrix" title="Permalink"></a></h2><p>If we have to deal with inputs where some elements of input matrix are <code>missing</code>:</p><pre><code class="language-julia-repl">julia&gt; X = [missing 1 2; 3 missing missing]
2×3 Array{Union{Missing, Int64},2}:
  missing  1         2
 3          missing   missing</code></pre><p>we can make use of <code>PreImputingMatrix</code>:</p><pre><code class="language-julia-repl">julia&gt; W = rand(1:2, 3, 2)
3×2 Array{Int64,2}:
 2  2
 2  2
 1  1

julia&gt; A = PreImputingMatrix(W)
3×2 PreImputingMatrix{Int64,Array{Int64,2},Array{Int64,1}}:
W:
 2  2
 2  2
 1  1

ψ:
 0  0</code></pre><p>As opposed to <code>PostImputingMatrix</code>, <code>A</code> now stores a vector of values <code>ψ</code> with length <code>size(W, 2)</code>. When we use it for multiplication:</p><pre><code class="language-julia-repl">julia&gt; A * X
3×3 Array{Int64,2}:
 6  2  4
 6  2  4
 3  1  2</code></pre><p>what happens is that when we perform a dot product of a row of <code>A</code> and a column of <code>X</code>, we first fill in values from <code>ψ</code> into the column <strong>before</strong> the multiplication is performed. Again, it is possible to compute gradients with respect to all three of <code>W</code>, <code>ψ</code> and <code>X</code> and therefore learn the appropriate default values in <code>ψ</code> from the data:</p><pre><code class="language-julia-repl">julia&gt; using Flux

julia&gt; gradient((A, X) -&gt; sum(A * X), A, X)
((W = [3 3; 3 3; 3 3], ψ = [5, 10]), [0 5 5; 5 0 0])</code></pre><h2 id="Model-reflection-with-missing-values"><a class="docs-heading-anchor" href="#Model-reflection-with-missing-values">Model reflection with missing values</a><a id="Model-reflection-with-missing-values-1"></a><a class="docs-heading-anchor-permalink" href="#Model-reflection-with-missing-values" title="Permalink"></a></h2><p>Model reflection takes <code>missing</code> values and types into account and creates appropriate (sub)models to handle them:</p><pre><code class="language-julia-repl">julia&gt; ds = ProductNode(ArrayNode.((missing_ngrams, missing_categorical, X)))
ProductNode with 3 obs
  ├── ArrayNode(5×3 NGramMatrix with Union{Missing, Int64} elements) with 3 obs
  ├── ArrayNode(5×3 MaybeHotMatrix with Union{Missing, Bool} elements) with 3 obs
  └── ArrayNode(2×3 Array with Union{Missing, Int64} elements) with 3 obs

julia&gt; m = reflectinmodel(ds)
ProductModel … ↦ ArrayModel(Dense(30, 10))
  ├── ArrayModel([post_imputing]Dense(5, 10))
  ├── ArrayModel([post_imputing]Dense(5, 10))
  └── ArrayModel([pre_imputing]Dense(2, 10))</code></pre><p>Here, <code>[pre_imputing]Dense</code> and <code>[post_imputing]Dense</code> are standard dense layers with a special matrix inside:</p><pre><code class="language-julia-repl">julia&gt; dense = m.ms[1].m; typeof(dense.W)
PostImputingMatrix{Float32,Array{Float32,2},Array{Float32,1}}</code></pre><p>Inside <code>Mill.jl</code> we add a special definition <code>Base.show</code> for these types for compact printing.</p><p>The <code>reflectinmodel</code> method use types to determine whether imputing is needed or not. Compare the following:</p><pre><code class="language-julia-repl">julia&gt; reflectinmodel(ArrayNode(randn(2, 3)))
ArrayModel(Dense(2, 10))

julia&gt; reflectinmodel(ArrayNode([1.0 2.0 missing; 4.0 missing missing]))
ArrayModel([pre_imputing]Dense(2, 10))

julia&gt; reflectinmodel(ArrayNode(Matrix{Union{Missing, Float64}}(randn(2, 3))))
ArrayModel([pre_imputing]Dense(2, 10))</code></pre><p>In the last case, the imputing type is returned even though there is no <code>missing</code> element in the matrix. Of course, the same applies to <code>MaybeHot*</code> types and <code>NGramMatrix</code>. This way, we can signify that even though there are no missing values in the available sample, we expect them to appear in the future and want our model compatible. If it is hard to determine this in advance a safe bet is to make all leaves in the model. The performance will not suffer because imputing types are as fast as their non-imputing counterparts on data not containing <code>missing</code> values and the only tradeoff is a slight increase in the number of parameters, some of which may never be used.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../leaf_data/">« Data in leaves</a><a class="docs-footer-nextpage" href="../custom/">Custom nodes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 4 February 2021 15:14">Thursday 4 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
