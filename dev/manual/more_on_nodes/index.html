<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>More on nodes · Mill.jl</title><meta name="title" content="More on nodes · Mill.jl"/><meta property="og:title" content="More on nodes · Mill.jl"/><meta property="twitter:title" content="More on nodes · Mill.jl"/><meta name="description" content="Documentation for Mill.jl."/><meta property="og:description" content="Documentation for Mill.jl."/><meta property="twitter:description" content="Documentation for Mill.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Mill.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Mill.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../motivation/">Motivation</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../nodes/">Nodes</a></li><li class="is-active"><a class="tocitem" href>More on nodes</a><ul class="internal"><li><a class="tocitem" href="#Node-nesting"><span>Node nesting</span></a></li><li><a class="tocitem" href="#Node-conveniences"><span>Node conveniences</span></a></li><li><a class="tocitem" href="#Metadata"><span>Metadata</span></a></li></ul></li><li><a class="tocitem" href="../reflectin/">Model reflection</a></li><li><a class="tocitem" href="../aggregation/">Bag aggregation</a></li><li><a class="tocitem" href="../leaf_data/">Data in leaves</a></li><li><a class="tocitem" href="../missing/">Missing data</a></li><li><a class="tocitem" href="../custom/">Custom nodes</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/musk/musk/">Musk</a></li><li><a class="tocitem" href="../../examples/jsons/">Processing JSONs</a></li><li><a class="tocitem" href="../../examples/gnn/">GNNs in 16 lines</a></li><li><a class="tocitem" href="../../examples/dag/">DAGs</a></li></ul></li><li><span class="tocitem">External tools</span><ul><li><a class="tocitem" href="../../tools/hierarchical/">HierarchicalUtils.jl</a></li></ul></li><li><span class="tocitem">Public API</span><ul><li><a class="tocitem" href="../../api/aggregation/">Aggregation</a></li><li><a class="tocitem" href="../../api/bags/">Bags</a></li><li><a class="tocitem" href="../../api/data_nodes/">Data nodes</a></li><li><a class="tocitem" href="../../api/model_nodes/">Model nodes</a></li><li><a class="tocitem" href="../../api/special_arrays/">Special Arrays</a></li><li><a class="tocitem" href="../../api/switches/">Switches</a></li><li><a class="tocitem" href="../../api/utilities/">Utilities</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../citation/">Citation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>More on nodes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>More on nodes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CTUAvastLab/Mill.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CTUAvastLab/Mill.jl/blob/master/docs/src/manual/more_on_nodes.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="More-on-nodes"><a class="docs-heading-anchor" href="#More-on-nodes">More on nodes</a><a id="More-on-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#More-on-nodes" title="Permalink"></a></h1><h2 id="Node-nesting"><a class="docs-heading-anchor" href="#Node-nesting">Node nesting</a><a id="Node-nesting-1"></a><a class="docs-heading-anchor-permalink" href="#Node-nesting" title="Permalink"></a></h2><p>The main advantage of the <a href="https://github.com/CTUAvastLab/Mill.jl"><code>Mill.jl</code></a> library is that it allows to arbitrarily nest and cross-product <a href="../../api/model_nodes/#Mill.BagModel"><code>BagModel</code></a>s, as described in Theorem 5 in [<a href="../../references/#Pevny2019">6</a>]. In other words, instances themselves may be represented in much more complex way than in the <a href="../../api/data_nodes/#Mill.BagNode"><code>BagNode</code></a> and <a href="../../api/model_nodes/#Mill.BagModel"><code>BagModel</code></a> example.</p><p>Let&#39;s start the demonstration by nesting two MIL problems. The outer MIL model contains three samples (outer-level bags), whose instances are (inner-level) bags themselves. The first outer-level bag contains one inner-level bag problem with two inner-level instances, the second outer-level bag contains two inner-level bags with total of three inner-level instances, and finally the third outer-level bag contains two inner bags with four instances:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ds = BagNode(BagNode(ArrayNode(randn(Float32, 4, 10)),
                            [1:2, 3:4, 5:5, 6:7, 8:10]),
                    [1:1, 2:3, 4:5])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagNode</span><span class="sgr90"><span class="sgr3">  3 obs</span></span>
<span class="sgr34">  ╰── </span><span class="sgr31">BagNode</span><span class="sgr90"><span class="sgr3">  5 obs</span></span>
<span class="sgr34">      </span><span class="sgr31">  ╰── </span>ArrayNode(4×10 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  10 obs</span></span></code></pre><p>Here is one example of a model, which is appropriate for this hierarchy:</p><pre><code class="language-julia hljs">using Flux: Dense, Chain, relu</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = BagModel(
               BagModel(
                   ArrayModel(Dense(4, 3, relu)),
                   SegmentedMeanMax(3),
                   Dense(6, 3, relu)),
               SegmentedMeanMax(3),
               Chain(Dense(6, 3, relu), Dense(3, 2)))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagModel ↦ [SegmentedMean(3); SegmentedMax(3)] ↦ Chain(Dense(6 =&gt; 3, relu), De </span><span class="sgr90">⋯</span>
<span class="sgr34">  ╰── </span><span class="sgr31">BagModel ↦ [SegmentedMean(3); SegmentedMax(3)] ↦ Dense(6 =&gt; 3, relu)</span><span class="sgr90"><span class="sgr3">  4  </span>⋯</span>
<span class="sgr34">      </span><span class="sgr31">  ╰── </span>ArrayModel(Dense(4 =&gt; 3, relu))<span class="sgr90"><span class="sgr3">  2 arrays, 15 params, 148 bytes</span></span></code></pre><p>and can be directly applied to obtain a result:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m(ds)</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Float32}:
 0.0  -0.0165677  -0.0404657
 0.0   0.013503    0.0329802</code></pre><p>Here we again make use of the property that even if each instance is represented with an arbitrarily complex structure, we always obtain a vector representation after applying instance model <code>im</code>, regardless of the complexity of <code>im</code> and <code>Mill.data(ds)</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m.im(Mill.data(ds))</code><code class="nohighlight hljs ansi" style="display:block;">3×5 Matrix{Float32}:
 0.0       0.545624  0.0  1.03625  0.018455
 0.0       0.708773  0.0  1.16774  0.0
 0.403142  0.740321  0.0  1.4657   0.556679</code></pre><p>In one final example we demonstrate a complex model consisting of all types of nodes introduced so far:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ds = BagNode(ProductNode((BagNode(randn(Float32, 4, 10),
                                         [1:2, 3:4, 5:5, 6:7, 8:10]),
                                 randn(Float32, 3, 5),
                                 BagNode(BagNode(randn(Float32, 2, 30),
                                                 [i:i+1 for i in 1:2:30]),
                                         [1:3, 4:6, 7:9, 10:12, 13:15]),
                                 randn(Float32, 2, 5))),
                    [1:1, 2:3, 4:5])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagNode</span><span class="sgr90"><span class="sgr3">  3 obs</span></span>
<span class="sgr34">  ╰── </span><span class="sgr31">ProductNode</span><span class="sgr90"><span class="sgr3">  5 obs</span></span>
<span class="sgr34">      </span><span class="sgr31">  ├── </span><span class="sgr32">BagNode</span><span class="sgr90"><span class="sgr3">  5 obs</span></span>
<span class="sgr34">      </span><span class="sgr31">  │   </span><span class="sgr32">  ╰── </span>ArrayNode(4×10 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  10 obs</span></span>
<span class="sgr34">      </span><span class="sgr31">  ├── </span>ArrayNode(3×5 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  5 obs</span></span>
<span class="sgr34">      </span><span class="sgr31">  ├── </span><span class="sgr32">BagNode</span><span class="sgr90"><span class="sgr3">  5 obs</span></span>
<span class="sgr34">      </span><span class="sgr31">  │   </span><span class="sgr32">  ╰── </span><span class="sgr33">BagNode</span><span class="sgr90"><span class="sgr3">  15 obs</span></span>
<span class="sgr34">      </span><span class="sgr31">  │   </span><span class="sgr32">      </span><span class="sgr33">  ╰── </span>ArrayNode(2×30 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  30 obs</span></span>
<span class="sgr34">      </span><span class="sgr31">  ╰── </span>ArrayNode(2×5 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  5 obs</span></span></code></pre><p>When data and model trees become complex, <a href="https://github.com/CTUAvastLab/Mill.jl"><code>Mill.jl</code></a> limits the printing. To inspect the whole tree, use <code>printtree</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; printtree(ds)</code><code class="nohighlight hljs ansi" style="display:block;">BagNode  3 obs
  ╰── ProductNode  5 obs
        ├── BagNode  5 obs
        │     ╰── ArrayNode(4×10 Array with Float32 elements)  10 obs
        ├── ArrayNode(3×5 Array with Float32 elements)  5 obs
        ├── BagNode  5 obs
        │     ╰── BagNode  15 obs
        │           ╰── ArrayNode(2×30 Array with Float32 elements)  30 obs
        ╰── ArrayNode(2×5 Array with Float32 elements)  5 obs</code></pre><p>Instead of defining a model manually, we can also make use of <a href="../reflectin/#Model-reflection">Model reflection</a>, another <a href="https://github.com/CTUAvastLab/Mill.jl"><code>Mill.jl</code></a> functionality, which simplifies model creation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = reflectinmodel(ds, d -&gt; Dense(d, 2), SegmentedMean)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagModel ↦ SegmentedMean(2) ↦ Dense(2 =&gt; 2)</span><span class="sgr90"><span class="sgr3">  3 arrays, 8 params, 160 bytes</span></span>
<span class="sgr34">  ╰── </span><span class="sgr31">ProductModel ↦ Dense(8 =&gt; 2)</span><span class="sgr90"><span class="sgr3">  2 arrays, 18 params, 160 bytes</span></span>
<span class="sgr34">      </span><span class="sgr31">  ├── </span><span class="sgr32">BagModel ↦ SegmentedMean(2) ↦ Dense(2 =&gt; 2)</span><span class="sgr90"><span class="sgr3">  3 arrays, 8 params, 1 </span>⋯</span>
<span class="sgr34">      </span><span class="sgr31">  │   </span><span class="sgr32">  ╰── </span>ArrayModel(Dense(4 =&gt; 2))<span class="sgr90"><span class="sgr3">  2 arrays, 10 params, 128 bytes</span></span>
<span class="sgr34">      </span><span class="sgr31">  ├── </span>ArrayModel(Dense(3 =&gt; 2))<span class="sgr90"><span class="sgr3">  2 arrays, 8 params, 120 bytes</span></span>
<span class="sgr34">      </span><span class="sgr31">  ├── </span><span class="sgr32">BagModel ↦ SegmentedMean(2) ↦ Dense(2 =&gt; 2)</span><span class="sgr90"><span class="sgr3">  3 arrays, 8 params, 1 </span>⋯</span>
<span class="sgr34">      </span><span class="sgr31">  │   </span><span class="sgr32">  ╰── </span><span class="sgr33">BagModel ↦ SegmentedMean(2) ↦ Dense(2 =&gt; 2)</span><span class="sgr90"><span class="sgr3">  3 arrays, 8 par </span>⋯</span>
<span class="sgr34">      </span><span class="sgr31">  │   </span><span class="sgr32">      </span><span class="sgr33">  ╰── </span>ArrayModel(Dense(2 =&gt; 2))<span class="sgr90"><span class="sgr3">  2 arrays, 6 params, 112 byt </span>⋯</span>
<span class="sgr34">      </span><span class="sgr31">  ╰── </span>ArrayModel(Dense(2 =&gt; 2))<span class="sgr90"><span class="sgr3">  2 arrays, 6 params, 112 bytes</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m(ds)</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Float32}:
 -0.0760647  0.0462476  -0.0648969
  0.030561   0.0626038  -0.0322707</code></pre><h2 id="Node-conveniences"><a class="docs-heading-anchor" href="#Node-conveniences">Node conveniences</a><a id="Node-conveniences-1"></a><a class="docs-heading-anchor-permalink" href="#Node-conveniences" title="Permalink"></a></h2><p>To make the handling of data and model hierarchies easier, <a href="https://github.com/CTUAvastLab/Mill.jl"><code>Mill.jl</code></a> provides several tools. Let&#39;s setup some data:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; AN = ArrayNode(Float32.([1 2 3 4; 5 6 7 8]))</code><code class="nohighlight hljs ansi" style="display:block;">2×4 ArrayNode{Matrix{Float32}, Nothing}:
 1.0  2.0  3.0  4.0
 5.0  6.0  7.0  8.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; AM = reflectinmodel(AN)</code><code class="nohighlight hljs ansi" style="display:block;">ArrayModel(Dense(2 =&gt; 10))<span class="sgr90"><span class="sgr3">  2 arrays, 30 params, 208 bytes</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BN = BagNode(AN, [1:1, 2:3, 4:4])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagNode</span><span class="sgr90"><span class="sgr3">  3 obs</span></span>
<span class="sgr34">  ╰── </span>ArrayNode(2×4 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  4 obs</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BM = reflectinmodel(BN)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagModel ↦ BagCount([SegmentedMean(10); SegmentedMax(10)]) ↦ Dense(21 =&gt; 10)</span><span class="sgr90"><span class="sgr3">   </span>⋯</span>
<span class="sgr34">  ╰── </span>ArrayModel(Dense(2 =&gt; 10))<span class="sgr90"><span class="sgr3">  2 arrays, 30 params, 208 bytes</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; PN = ProductNode(a=Float32.([1 2 3; 4 5 6]), b=BN)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">ProductNode</span><span class="sgr90"><span class="sgr3">  3 obs</span></span>
<span class="sgr34">  ├── a: </span>ArrayNode(2×3 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  3 obs</span></span>
<span class="sgr34">  ╰── b: </span><span class="sgr31">BagNode</span><span class="sgr90"><span class="sgr3">  3 obs</span></span>
<span class="sgr34">         </span><span class="sgr31">  ╰── </span>ArrayNode(2×4 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  4 obs</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; PM = reflectinmodel(PN)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">ProductModel ↦ Dense(20 =&gt; 10)</span><span class="sgr90"><span class="sgr3">  2 arrays, 210 params, 928 bytes</span></span>
<span class="sgr34">  ├── a: </span>ArrayModel(Dense(2 =&gt; 10))<span class="sgr90"><span class="sgr3">  2 arrays, 30 params, 208 bytes</span></span>
<span class="sgr34">  ╰── b: </span><span class="sgr31">BagModel ↦ BagCount([SegmentedMean(10); SegmentedMax(10)]) ↦ Dense(21 </span><span class="sgr90">⋯</span>
<span class="sgr34">         </span><span class="sgr31">  ╰── </span>ArrayModel(Dense(2 =&gt; 10))<span class="sgr90"><span class="sgr3">  2 arrays, 30 params, 208 bytes</span></span></code></pre><h3 id="Function:-numobs"><a class="docs-heading-anchor" href="#Function:-numobs">Function: <code>numobs</code></a><a id="Function:-numobs-1"></a><a class="docs-heading-anchor-permalink" href="#Function:-numobs" title="Permalink"></a></h3><p><code>numobs</code> function from <a href="https://github.com/JuliaML/MLUtils.jl"><code>MLUtils.jl</code></a> returns a number of samples from the current level point of view. This number usually increases as we go down the tree when <a href="../../api/data_nodes/#Mill.BagNode"><code>BagNode</code></a>s are involved, as each bag may contain more than one instance.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; numobs(AN)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numobs(BN)</code><code class="nohighlight hljs ansi" style="display:block;">3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numobs(PN)</code><code class="nohighlight hljs ansi" style="display:block;">3</code></pre><h3 id="Indexing-and-Slicing"><a class="docs-heading-anchor" href="#Indexing-and-Slicing">Indexing and Slicing</a><a id="Indexing-and-Slicing-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing-and-Slicing" title="Permalink"></a></h3><p>Indexing in <a href="https://github.com/CTUAvastLab/Mill.jl"><code>Mill.jl</code></a> operates <strong>on the level of observations</strong>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; AN[1]</code><code class="nohighlight hljs ansi" style="display:block;">2×1 ArrayNode{Matrix{Float32}, Nothing}:
 1.0
 5.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numobs(ans)</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BN[2]</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagNode</span><span class="sgr90"><span class="sgr3">  1 obs</span></span>
<span class="sgr34">  ╰── </span>ArrayNode(2×2 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  2 obs</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numobs(ans)</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; PN[3]</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">ProductNode</span><span class="sgr90"><span class="sgr3">  1 obs</span></span>
<span class="sgr34">  ├── a: </span>ArrayNode(2×1 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  1 obs</span></span>
<span class="sgr34">  ╰── b: </span><span class="sgr31">BagNode</span><span class="sgr90"><span class="sgr3">  1 obs</span></span>
<span class="sgr34">         </span><span class="sgr31">  ╰── </span>ArrayNode(2×1 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  1 obs</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numobs(ans)</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; AN[[1, 4]]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 ArrayNode{Matrix{Float32}, Nothing}:
 1.0  4.0
 5.0  8.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numobs(ans)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BN[1:2]</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagNode</span><span class="sgr90"><span class="sgr3">  2 obs</span></span>
<span class="sgr34">  ╰── </span>ArrayNode(2×3 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  3 obs</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numobs(ans)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; PN[[2, 3]]</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">ProductNode</span><span class="sgr90"><span class="sgr3">  2 obs</span></span>
<span class="sgr34">  ├── a: </span>ArrayNode(2×2 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  2 obs</span></span>
<span class="sgr34">  ╰── b: </span><span class="sgr31">BagNode</span><span class="sgr90"><span class="sgr3">  2 obs</span></span>
<span class="sgr34">         </span><span class="sgr31">  ╰── </span>ArrayNode(2×3 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  3 obs</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numobs(ans)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; PN[Int[]]</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">ProductNode</span><span class="sgr90"><span class="sgr3">  0 obs</span></span>
<span class="sgr34">  ├── a: </span>ArrayNode(2×0 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  0 obs</span></span>
<span class="sgr34">  ╰── b: </span><span class="sgr31">BagNode</span><span class="sgr90"><span class="sgr3">  0 obs</span></span>
<span class="sgr34">         </span><span class="sgr31">  ╰── </span>ArrayNode(2×0 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  0 obs</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numobs(ans)</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>This may be useful for creating minibatches and their permutations.</p><p>Note that apart from the perhaps apparent recurrent effect, this operation requires other implicit actions, such as properly recomputing bag indices:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; BN.bags</code><code class="nohighlight hljs ansi" style="display:block;">AlignedBags{Int64}(UnitRange{Int64}[1:1, 2:3, 4:4])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BN[[1, 3]].bags</code><code class="nohighlight hljs ansi" style="display:block;">AlignedBags{Int64}(UnitRange{Int64}[1:1, 2:2])</code></pre><h3 id="Function:-[catobs](@ref)"><a class="docs-heading-anchor" href="#Function:-[catobs](@ref)">Function: <a href="../../api/data_nodes/#Mill.catobs"><code>catobs</code></a></a><a id="Function:-[catobs](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Function:-[catobs](@ref)" title="Permalink"></a></h3><p><a href="../../api/data_nodes/#Mill.catobs"><code>catobs</code></a> function concatenates several samples (datasets) together:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; catobs(AN[1], AN[4])</code><code class="nohighlight hljs ansi" style="display:block;">2×2 ArrayNode{Matrix{Float32}, Nothing}:
 1.0  4.0
 5.0  8.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; catobs(BN[3], BN[[2, 1]])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">BagNode</span><span class="sgr90"><span class="sgr3">  3 obs</span></span>
<span class="sgr34">  ╰── </span>ArrayNode(2×4 Array with Float32 elements)<span class="sgr90"><span class="sgr3">  4 obs</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; catobs(PN[[1, 2]], PN[3:3]) == PN</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Again, the effect is recurrent and everything is appropriately recomputed:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; BN.bags</code><code class="nohighlight hljs ansi" style="display:block;">AlignedBags{Int64}(UnitRange{Int64}[1:1, 2:3, 4:4])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; catobs(BN[3], BN[[1]]).bags</code><code class="nohighlight hljs ansi" style="display:block;">AlignedBags{Int64}(UnitRange{Int64}[1:1, 2:2])</code></pre><p>This operation is an analogy to what is usually done in the classical setting. If every observation is represented as a vector of features, each (mini)batch of samples is first concatenated into one matrix and the whole matrix is run through the neural network using fast matrix multiplication procedures. The same reasoning applies here, but instead of <code>Base.cat</code>, <a href="../../api/data_nodes/#Mill.catobs"><code>catobs</code></a> is needed.</p><p>Equipped with everything mentioned above there are two different ways to construct minibatches from data. First option, applicable mainly to smaller datasets, is to load all avaiable data into memory, store it as one big data node containing all observations, and use <a href="#Indexing-and-Slicing">Indexing and Slicing</a> to obtain minibatches. Such approach is demonstrated in the <a href="../../examples/musk/musk/#Musk">Musk</a> example. The other option is to read all observations into memory separately (or load them on demand) and construct minibatches with <a href="../../api/data_nodes/#Mill.catobs"><code>catobs</code></a>.</p><div class="admonition is-category-ukn" id="More-tips-632553753d2e7d4"><header class="admonition-header">More tips<a class="admonition-anchor" href="#More-tips-632553753d2e7d4" title="Permalink"></a></header><div class="admonition-body"><p>For more tips for handling datasets and models, see <a href="../../tools/hierarchical/#HierarchicalUtils.jl">External tools</a>.</p></div></div><h2 id="Metadata"><a class="docs-heading-anchor" href="#Metadata">Metadata</a><a id="Metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata" title="Permalink"></a></h2><p>Each <a href="../../api/data_nodes/#Mill.AbstractMillNode"><code>AbstractMillNode</code></a> can also carry arbitrary <strong>metadata</strong> (defaulting to <code>nothing</code>). Metadata is provided upon construction of the node and accessed metadata by <a href="../../api/data_nodes/#Mill.metadata"><code>Mill.metadata</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; n1 = ArrayNode(randn(2, 2), [&quot;metadata&quot;])</code><code class="nohighlight hljs ansi" style="display:block;">2×2 ArrayNode{Matrix{Float64}, Vector{String}}:
 -0.22684270643341806   1.3321657770216255
  0.015328464950175435  1.059974135058343</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Mill.metadata(n1)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{String}:
 &quot;metadata&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; n2 = ProductNode(n1, [1 3; 2 4])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr34">ProductNode</span><span class="sgr90"><span class="sgr3">  2 obs</span></span>
<span class="sgr34">  ╰── </span>ArrayNode(2×2 Array with Float64 elements)<span class="sgr90"><span class="sgr3">  2 obs</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Mill.metadata(n2)</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Int64}:
 1  3
 2  4</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nodes/">« Nodes</a><a class="docs-footer-nextpage" href="../reflectin/">Model reflection »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 23 July 2025 10:46">Wednesday 23 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
