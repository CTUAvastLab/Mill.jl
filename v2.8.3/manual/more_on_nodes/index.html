<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>More on nodes · Mill.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Mill.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Mill.jl logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../motivation/">Motivation</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../nodes/">Nodes</a></li><li class="is-active"><a class="tocitem" href>More on nodes</a><ul class="internal"><li><a class="tocitem" href="#Node-nesting"><span>Node nesting</span></a></li><li><a class="tocitem" href="#Node-conveniences"><span>Node conveniences</span></a></li><li><a class="tocitem" href="#Metadata"><span>Metadata</span></a></li></ul></li><li><a class="tocitem" href="../reflectin/">Model reflection</a></li><li><a class="tocitem" href="../aggregation/">Bag aggregation</a></li><li><a class="tocitem" href="../leaf_data/">Data in leaves</a></li><li><a class="tocitem" href="../missing/">Missing data</a></li><li><a class="tocitem" href="../custom/">Custom nodes</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/musk/musk/">Musk</a></li><li><a class="tocitem" href="../../examples/gnn/">GNNs in 16 lines</a></li><li><a class="tocitem" href="../../examples/dag/">DAGs</a></li><li><a class="tocitem" href="../../examples/jsons/">Processing JSONs</a></li></ul></li><li><span class="tocitem">External tools</span><ul><li><a class="tocitem" href="../../tools/hierarchical/">HierarchicalUtils.jl</a></li></ul></li><li><span class="tocitem">Public API</span><ul><li><a class="tocitem" href="../../api/aggregation/">Aggregation</a></li><li><a class="tocitem" href="../../api/bags/">Bags</a></li><li><a class="tocitem" href="../../api/data_nodes/">Data nodes</a></li><li><a class="tocitem" href="../../api/model_nodes/">Model nodes</a></li><li><a class="tocitem" href="../../api/special_arrays/">Special Arrays</a></li><li><a class="tocitem" href="../../api/switches/">Switches</a></li><li><a class="tocitem" href="../../api/utilities/">Utilities</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../citation/">Citation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>More on nodes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>More on nodes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CTUAvastLab/Mill.jl/blob/master/docs/src/manual/more_on_nodes.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="More-on-nodes"><a class="docs-heading-anchor" href="#More-on-nodes">More on nodes</a><a id="More-on-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#More-on-nodes" title="Permalink"></a></h1><h2 id="Node-nesting"><a class="docs-heading-anchor" href="#Node-nesting">Node nesting</a><a id="Node-nesting-1"></a><a class="docs-heading-anchor-permalink" href="#Node-nesting" title="Permalink"></a></h2><p>The main advantage of the <a href="https://github.com/CTUAvastLab/Mill.jl"><code>Mill.jl</code></a> library is that it allows to arbitrarily nest and cross-product <a href="../../api/model_nodes/#Mill.BagModel"><code>BagModel</code></a>s, as described in Theorem 5 in <a href="../../references/#Pevny2019">Tomáš Pevný, Vojtěch Kovařík (2019)</a>. In other words, instances themselves may be represented in much more complex way than in the <a href="../../api/data_nodes/#Mill.BagNode"><code>BagNode</code></a> and <a href="../../api/model_nodes/#Mill.BagModel"><code>BagModel</code></a> example.</p><p>Let&#39;s start the demonstration by nesting two MIL problems. The outer MIL model contains three samples (outer-level bags), whose instances are (inner-level) bags themselves. The first outer-level bag contains one inner-level bag problem with two inner-level instances, the second outer-level bag contains two inner-level bags with total of three inner-level instances, and finally the third outer-level bag contains two inner bags with four instances:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ds = BagNode(BagNode(ArrayNode(randn(4, 10)),
                            [1:2, 3:4, 5:5, 6:7, 8:10]),
                    [1:1, 2:3, 4:5])</code><code class="nohighlight hljs ansi" style="display:block;">BagNode  # 3 obs, 120 bytes
  ╰── BagNode  # 5 obs, 144 bytes
        ╰── ArrayNode(4×10 Array with Float64 elements)  # 10 obs, 368 bytes</code></pre><p>Here is one example of a model, which is appropriate for this hierarchy:</p><pre><code class="language-julia hljs">using Flux: Dense, Chain, relu</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = BagModel(
               BagModel(
                   ArrayModel(Dense(4, 3, relu)),
                   SegmentedMeanMax(3),
                   Dense(6, 3, relu)),
               SegmentedMeanMax(3),
               Chain(Dense(6, 3, relu), Dense(3, 2)))</code><code class="nohighlight hljs ansi" style="display:block;">BagModel ↦ [SegmentedMean(3); SegmentedMax(3)] ↦ Chain(Dense(6 =&gt; 3, relu), Dense(3 =&gt; 2))  # 6 arrays, 35 params, 380 byte ⋯
  ╰── BagModel ↦ [SegmentedMean(3); SegmentedMax(3)] ↦ Dense(6 =&gt; 3, relu)  # 4 arrays, 27 params, 268 bytes
        ╰── ArrayModel(Dense(4 =&gt; 3, relu))  # 2 arrays, 15 params, 140 bytes</code></pre><p>and can be directly applied to obtain a result:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m(ds)</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Float64}:
 -0.00696584  -0.106253   -0.696413
  0.00506909   0.0773212   0.465453</code></pre><p>Here we again make use of the property that even if each instance is represented with an arbitrarily complex structure, we always obtain a vector representation after applying instance model <code>im</code>, regardless of the complexity of <code>im</code> and <code>Mill.data(ds)</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m.im(Mill.data(ds))</code><code class="nohighlight hljs ansi" style="display:block;">3×5 Matrix{Float64}:
 0.0212174  0.702164  0.0405164  1.01459   0.695818
 0.0        0.356143  0.0195324  0.241343  0.0
 0.0        0.0       0.0        0.0       0.550563</code></pre><p>In one final example we demonstrate a complex model consisting of all types of nodes introduced so far:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ds = BagNode(ProductNode((BagNode(randn(4, 10),
                                         [1:2, 3:4, 5:5, 6:7, 8:10]),
                                 randn(3, 5),
                                 BagNode(BagNode(randn(2, 30),
                                                 [i:i+1 for i in 1:2:30]),
                                         [1:3, 4:6, 7:9, 10:12, 13:15]),
                                 randn(2, 5))),
                    [1:1, 2:3, 4:5])</code><code class="nohighlight hljs ansi" style="display:block;">BagNode  # 3 obs, 160 bytes
  ╰── ProductNode  # 5 obs, 56 bytes
        ├── BagNode  # 5 obs, 144 bytes
        │     ╰── ArrayNode(4×10 Array with Float64 elements)  # 10 obs, 368 bytes
        ├── ArrayNode(3×5 Array with Float64 elements)  # 5 obs, 168 bytes
        ├── BagNode  # 5 obs, 152 bytes
        │     ╰── BagNode  # 15 obs, 304 bytes
        │           ╰── ArrayNode(2×30 Array with Float64 elements)  # 30 obs, 528 bytes
        ╰── ArrayNode(2×5 Array with Float64 elements)  # 5 obs, 128 bytes</code></pre><p>As data and model trees tend to be complex, <code>Mill</code> limits the printing. To inspect the whole tree, use <code>printtree</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; printtree(ds)</code><code class="nohighlight hljs ansi" style="display:block;">BagNode  # 3 obs, 160 bytes
  ╰── ProductNode  # 5 obs, 56 bytes
        ├── BagNode  # 5 obs, 144 bytes
        │     ╰── ArrayNode(4×10 Array with Float64 elements)  # 10 obs, 368 bytes
        ├── ArrayNode(3×5 Array with Float64 elements)  # 5 obs, 168 bytes
        ├── BagNode  # 5 obs, 152 bytes
        │     ╰── BagNode  # 15 obs, 304 bytes
        │           ╰── ArrayNode(2×30 Array with Float64 elements)  # 30 obs, 528 bytes
        ╰── ArrayNode(2×5 Array with Float64 elements)  # 5 obs, 128 bytes</code></pre><p>Instead of defining a model manually, we can also make use of <a href="../reflectin/#Model-reflection">Model reflection</a>, another <code>Mill</code> functionality, which simplifies model creation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = reflectinmodel(ds, d -&gt; Dense(d, 2), SegmentedMean)</code><code class="nohighlight hljs ansi" style="display:block;">BagModel ↦ SegmentedMean(2) ↦ Dense(2 =&gt; 2)  # 3 arrays, 8 params, 152 bytes
  ╰── ProductModel ↦ Dense(8 =&gt; 2)  # 2 arrays, 18 params, 152 bytes
        ├── BagModel ↦ SegmentedMean(2) ↦ Dense(2 =&gt; 2)  # 3 arrays, 8 params, 152 bytes
        │     ╰── ArrayModel(Dense(4 =&gt; 2))  # 2 arrays, 10 params, 120 bytes
        ├── ArrayModel(Dense(3 =&gt; 2))  # 2 arrays, 8 params, 112 bytes
        ├── BagModel ↦ SegmentedMean(2) ↦ Dense(2 =&gt; 2)  # 3 arrays, 8 params, 152 bytes
        │     ╰── BagModel ↦ SegmentedMean(2) ↦ Dense(2 =&gt; 2)  # 3 arrays, 8 params, 152 bytes
        │           ╰── ArrayModel(Dense(2 =&gt; 2))  # 2 arrays, 6 params, 104 bytes
        ╰── ArrayModel(Dense(2 =&gt; 2))  # 2 arrays, 6 params, 104 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m(ds)</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Float64}:
 -1.14457  2.45443  -0.639414
 -1.14707  2.10312  -0.666063</code></pre><h2 id="Node-conveniences"><a class="docs-heading-anchor" href="#Node-conveniences">Node conveniences</a><a id="Node-conveniences-1"></a><a class="docs-heading-anchor-permalink" href="#Node-conveniences" title="Permalink"></a></h2><p>To make the handling of data and model hierarchies easier, <code>Mill</code> provides several tools. Let&#39;s setup some data:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; AN = ArrayNode(Float32.([1 2 3 4; 5 6 7 8]))</code><code class="nohighlight hljs ansi" style="display:block;">2×4 ArrayNode{Matrix{Float32}, Nothing}:
 1.0  2.0  3.0  4.0
 5.0  6.0  7.0  8.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; AM = reflectinmodel(AN)</code><code class="nohighlight hljs ansi" style="display:block;">ArrayModel(Dense(2 =&gt; 10))  # 2 arrays, 30 params, 200 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BN = BagNode(AN, [1:1, 2:3, 4:4])</code><code class="nohighlight hljs ansi" style="display:block;">BagNode  # 3 obs, 112 bytes
  ╰── ArrayNode(2×4 Array with Float32 elements)  # 4 obs, 80 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BM = reflectinmodel(BN)</code><code class="nohighlight hljs ansi" style="display:block;">BagModel ↦ BagCount([SegmentedMean(10); SegmentedMax(10)]) ↦ Dense(21 =&gt; 10)  # 4 arrays, 240 params, 1.094 KiB
  ╰── ArrayModel(Dense(2 =&gt; 10))  # 2 arrays, 30 params, 200 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; PN = ProductNode(a=Float32.([1 2 3; 4 5 6]), b=BN)</code><code class="nohighlight hljs ansi" style="display:block;">ProductNode  # 3 obs, 24 bytes
  ├── a: ArrayNode(2×3 Array with Float32 elements)  # 3 obs, 72 bytes
  ╰── b: BagNode  # 3 obs, 112 bytes
           ╰── ArrayNode(2×4 Array with Float32 elements)  # 4 obs, 80 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; PM = reflectinmodel(PN)</code><code class="nohighlight hljs ansi" style="display:block;">ProductModel ↦ Dense(20 =&gt; 10)  # 2 arrays, 210 params, 920 bytes
  ├── a: ArrayModel(Dense(2 =&gt; 10))  # 2 arrays, 30 params, 200 bytes
  ╰── b: BagModel ↦ BagCount([SegmentedMean(10); SegmentedMax(10)]) ↦ Dense(21 =&gt; 10)  # 4 arrays, 240 params, 1.094 KiB
           ╰── ArrayModel(Dense(2 =&gt; 10))  # 2 arrays, 30 params, 200 bytes</code></pre><h3 id="Function:-nobs"><a class="docs-heading-anchor" href="#Function:-nobs">Function: <code>nobs</code></a><a id="Function:-nobs-1"></a><a class="docs-heading-anchor-permalink" href="#Function:-nobs" title="Permalink"></a></h3><p><code>nobs</code> function from <a href="https://github.com/JuliaStats/StatsBase.jl"><code>StatsBase.jl</code></a> returns a number of samples from the current level point of view. This number usually increases as we go down the tree when <a href="../../api/data_nodes/#Mill.BagNode"><code>BagNode</code></a>s are involved, as each bag may contain more than one instance.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using StatsBase: nobs</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nobs(AN)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nobs(BN)</code><code class="nohighlight hljs ansi" style="display:block;">3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nobs(PN)</code><code class="nohighlight hljs ansi" style="display:block;">3</code></pre><h3 id="Indexing-and-Slicing"><a class="docs-heading-anchor" href="#Indexing-and-Slicing">Indexing and Slicing</a><a id="Indexing-and-Slicing-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing-and-Slicing" title="Permalink"></a></h3><p>Indexing in [<code>Mill</code>] operates <strong>on the level of observations</strong>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; AN[1]</code><code class="nohighlight hljs ansi" style="display:block;">2×1 ArrayNode{Matrix{Float32}, Nothing}:
 1.0
 5.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nobs(ans)</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BN[2]</code><code class="nohighlight hljs ansi" style="display:block;">BagNode  # 1 obs, 80 bytes
  ╰── ArrayNode(2×2 Array with Float32 elements)  # 2 obs, 64 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nobs(ans)</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; PN[3]</code><code class="nohighlight hljs ansi" style="display:block;">ProductNode  # 1 obs, 24 bytes
  ├── a: ArrayNode(2×1 Array with Float32 elements)  # 1 obs, 56 bytes
  ╰── b: BagNode  # 1 obs, 80 bytes
           ╰── ArrayNode(2×1 Array with Float32 elements)  # 1 obs, 56 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nobs(ans)</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; AN[[1, 4]]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 ArrayNode{Matrix{Float32}, Nothing}:
 1.0  4.0
 5.0  8.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nobs(ans)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BN[1:2]</code><code class="nohighlight hljs ansi" style="display:block;">BagNode  # 2 obs, 96 bytes
  ╰── ArrayNode(2×3 Array with Float32 elements)  # 3 obs, 72 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nobs(ans)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; PN[[2, 3]]</code><code class="nohighlight hljs ansi" style="display:block;">ProductNode  # 2 obs, 24 bytes
  ├── a: ArrayNode(2×2 Array with Float32 elements)  # 2 obs, 64 bytes
  ╰── b: BagNode  # 2 obs, 96 bytes
           ╰── ArrayNode(2×3 Array with Float32 elements)  # 3 obs, 72 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nobs(ans)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; PN[Int[]]</code><code class="nohighlight hljs ansi" style="display:block;">ProductNode  # 0 obs, 24 bytes
  ├── a: ArrayNode(2×0 Array with Float32 elements)  # 0 obs, 48 bytes
  ╰── b: BagNode  # 0 obs, 64 bytes
           ╰── ArrayNode(2×0 Array with Float32 elements)  # 0 obs, 48 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nobs(ans)</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>This may be useful for creating minibatches and their permutations.</p><p>Note that apart from the perhaps apparent recurrent effect, this operation requires other implicit actions, such as properly recomputing bag indices:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; BN.bags</code><code class="nohighlight hljs ansi" style="display:block;">AlignedBags{Int64}(UnitRange{Int64}[1:1, 2:3, 4:4])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BN[[1, 3]].bags</code><code class="nohighlight hljs ansi" style="display:block;">AlignedBags{Int64}(UnitRange{Int64}[1:1, 2:2])</code></pre><h3 id="Function:-[catobs](@ref)"><a class="docs-heading-anchor" href="#Function:-[catobs](@ref)">Function: <a href="../../api/data_nodes/#Mill.catobs"><code>catobs</code></a></a><a id="Function:-[catobs](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Function:-[catobs](@ref)" title="Permalink"></a></h3><p><a href="../../api/data_nodes/#Mill.catobs"><code>catobs</code></a> function concatenates several samples (datasets) together:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; catobs(AN[1], AN[4])</code><code class="nohighlight hljs ansi" style="display:block;">2×2 ArrayNode{Matrix{Float32}, Nothing}:
 1.0  4.0
 5.0  8.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; catobs(BN[3], BN[[2, 1]])</code><code class="nohighlight hljs ansi" style="display:block;">BagNode  # 3 obs, 112 bytes
  ╰── ArrayNode(2×4 Array with Float32 elements)  # 4 obs, 80 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; catobs(PN[[1, 2]], PN[3:3]) == PN</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Again, the effect is recurrent and everything is appropriately recomputed:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; BN.bags</code><code class="nohighlight hljs ansi" style="display:block;">AlignedBags{Int64}(UnitRange{Int64}[1:1, 2:3, 4:4])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; catobs(BN[3], BN[[1]]).bags</code><code class="nohighlight hljs ansi" style="display:block;">AlignedBags{Int64}(UnitRange{Int64}[1:1, 2:2])</code></pre><p>This operation is an analogy to what is usually done in the classical setting. If every observation is represented as a vector of features, each (mini)batch of samples is first concatenated into one matrix and the whole matrix is run through the neural network using fast matrix multiplication procedures. The same reasoning applies here, but instead of <code>Base.cat</code>, <a href="../../api/data_nodes/#Mill.catobs"><code>catobs</code></a> is needed.</p><p>Equipped with everything mentioned above there are two different ways to construct minibatches from data. First option, applicable mainly to smaller datasets, is to load all avaiable data into memory, store it as one big data node containing all observations, and use <a href="#Indexing-and-Slicing">Indexing and Slicing</a> to obtain minibatches. Such approach is demonstrated in the <a href="../../examples/musk/musk/#Musk">Musk</a> example. The other option is to read all observations into memory separately (or load them on demand) and construct minibatches with <a href="../../api/data_nodes/#Mill.catobs"><code>catobs</code></a>.</p><div class="admonition is-category-ukn"><header class="admonition-header">More tips</header><div class="admonition-body"><p>For more tips for handling datasets and models, see <a href="../../tools/hierarchical/#HierarchicalUtils.jl">External tools</a>.</p></div></div><h2 id="Metadata"><a class="docs-heading-anchor" href="#Metadata">Metadata</a><a id="Metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata" title="Permalink"></a></h2><p>Each <a href="../../api/data_nodes/#Mill.AbstractMillNode"><code>AbstractMillNode</code></a> can also carry arbitrary <strong>metadata</strong> (defaulting to <code>nothing</code>). Metadata is provided upon construction of the node and accessed metadata by <a href="../../api/data_nodes/#Mill.metadata"><code>Mill.metadata</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; n1 = ArrayNode(randn(2, 2), [&quot;metadata&quot;])</code><code class="nohighlight hljs ansi" style="display:block;">2×2 ArrayNode{Matrix{Float64}, Vector{String}}:
  0.7047979540448649   2.461859180788529
 -0.10147425418334251  0.732663571917291</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Mill.metadata(n1)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{String}:
 &quot;metadata&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; n2 = ProductNode(n1, [1 3; 2 4])</code><code class="nohighlight hljs ansi" style="display:block;">ProductNode  # 2 obs, 96 bytes
  ╰── ArrayNode(2×2 Array with Float64 elements)  # 2 obs, 152 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Mill.metadata(n2)</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Int64}:
 1  3
 2  4</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nodes/">« Nodes</a><a class="docs-footer-nextpage" href="../reflectin/">Model reflection »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 13 January 2023 12:32">Friday 13 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
